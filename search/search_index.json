{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ticktack","text":"<p>A lightweight, open-source carbon box modelling library, adapted for modelling tree ring radiocarbon time series.</p>"},{"location":"#contributors","title":"Contributors","text":"<p>Utkarsh Sharma, Qingyuan Zhang, Benjamin Pope</p>"},{"location":"#overview","title":"Overview","text":"<p>Radiocarbon measurements from tree rings allow us to recover measurements of cosmic radiation from the distant past, and exquisitely calibrate carbon dating of archaeological sites. But in order to infer cosmic production rates from raw \u0394C14 data, we need to model the entire global carbon cycle, from the production of radiocarbon in the stratosphere and troposphere to its uptake by the oceans and biosphere. Many such competing models exist, in which the Earth system is partitioned into 'boxes' with reservoirs of C12, C14, and coefficients of flow between them.</p> <p><code>ticktack</code> is the first open-source package for radiocarbon box modelling, allowing you to specify your own model or load a model with the same parameters as several leading closed-source models. Built in Python on Google Jax, it solves the carbon box ordinary differential equations using the Runge-Kutta method, on arbitrarily fine time grids and with arbitrary production rates. This forwards model is connected via a simple API to Bayesian inference using MCMC: currently we support only emcee, but implementations are in progress of HMC and nested sampling.  </p>"},{"location":"#installation","title":"Installation","text":"<p>The easiest way to install is from PyPI: just use</p> <p><code>pip install ticktack</code></p> <p>To install from source: clone this git repo, enter the directory, and run</p> <p><code>python setup.py install</code></p>"},{"location":"#running-the-tests","title":"Running the Tests","text":"<p>To run the tests just, install pytest, navigate to the <code>tests/</code> directory, and type <code>pytest</code> at the command line. <code>pytest</code> will automatically detect the tests.</p>"},{"location":"#license","title":"License","text":"<p>We invite anyone interested to use and modify this code under a MIT license.</p>"},{"location":"#name","title":"Name","text":"<p>The 'little boxes' in Malvina Reynolds' famous song are all made of ticky-tacky, and they all look just the same. Here we provide an open-source toolkit for reproducing and extending carbon box models for radiocarbon analysis, and we expect they will be as interchangeable as Malvina Reynolds' boxes!</p>"},{"location":"box_api/","title":"Documentation for <code>Box</code>","text":"<p>Box class which represents each individual box in the carbon model.</p>"},{"location":"box_api/#ticktack.ticktack.Box.__init__","title":"<code>__init__(name, reservoir, production_coefficient=0.0, hemisphere='None')</code>","text":"<p>init method to initialise object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the Box.</p> required <code>reservoir</code> <code>float</code> <p>reservoir content of the Box.</p> required <code>production_coefficient</code> <code>float</code> <p>production coefficient of the Box. Defaults to 0.</p> <code>0.0</code> <code>hemisphere</code> <code>str</code> <p>hemisphere that this box is in. Defaults to None (i.e. this box is not part of an inter-hemispheric system).</p> <code>'None'</code>"},{"location":"box_api/#ticktack.ticktack.Box.get_hemisphere","title":"<code>get_hemisphere()</code>","text":"<p>Getter method for the hemisphere of the Box Class.</p> <p>Returns:</p> Type Description <code>str</code> <p>hemisphere the box is in.</p>"},{"location":"box_api/#ticktack.ticktack.Box.get_name","title":"<code>get_name()</code>","text":"<p>Getter method for the name of the Box Class.</p> <p>Returns:</p> Type Description <code>str</code> <p>name of the Box.</p>"},{"location":"box_api/#ticktack.ticktack.Box.get_reservoir_content","title":"<code>get_reservoir_content()</code>","text":"<p>Getter method for the reservoir content of the Box Class.</p> <p>Returns:</p> Type Description <code>float</code> <p>reservoir content of the box.</p>"},{"location":"box_api/#ticktack.ticktack.Box.get_production","title":"<code>get_production()</code>","text":"<p>Getter method for the production coefficient of the Box Class.</p> <p>Returns:</p> Type Description <code> float</code> <p>production coefficient of the box.</p>"},{"location":"box_api/#ticktack.ticktack.Box.__str__","title":"<code>__str__()</code>","text":"<p>Overrides the default string behaviour to display a user-friendly output.</p> <p>Returns:</p> Type Description <code>str</code> <p>string representation of the Box Object returned in the following form - name:reservoir size:production coefficient</p>"},{"location":"cbm_api/","title":"Documentation for <code>CarbonBoxModel</code>","text":""},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel","title":"<code>CarbonBoxModel</code>","text":"<p>Carbon Box Model class which represents the box model which is made up of Box Objects and Flux Objects.</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.__init__","title":"<code>__init__(production_rate_units='kg/yr', flow_rate_units='Gt/yr')</code>","text":"<p>Init method for creating an object of this class.</p> <p>Parameters:</p> Name Type Description Default <code>production_rate_units</code> <code>str</code> <p>units for the production rate. Only valid units are 'kg/yr' or 'atoms/cm^2/s'.</p> <code>'kg/yr'</code> <code>flow_rate_units</code> <code>str</code> <p>units for the flow rate. Only valid values are 'Gt/yr' or '1/yr'.</p> <code>'Gt/yr'</code>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.add_edges","title":"<code>add_edges(flow_objs)</code>","text":"<p>Adds the flow objects specified in the list to the carbon box model. If any of the objects in the list are     not an instance of Flow Class then it throws a ValueError.</p> <p>Parameters:</p> Name Type Description Default <code>flow_objs</code> <code>list | ndarray</code> <p>A list of Flow objects to add to the Carbon Box Model.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the objects in the list are not of type Flow.</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.add_nodes","title":"<code>add_nodes(nodes)</code>","text":"<p>Adds the nodes to the Carbon Box Model. If the node already exists within the carbon box model node list, then it is not added. If the node is not a Box Class Instance, then it raises a ValueError.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list | ndarray</code> <p>A list of nodes of Type Box to add to the carbon box model.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the objects in the list are not of type Box.</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.bin_data","title":"<code>bin_data(data, time_oversample, time_out, growth)</code>","text":"<p>Bins the data given based on the oversample and the growth season according to Schulman's convention. Can handle any contiguous growth season, even over the year.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>the data which to bin.</p> required <code>time_oversample</code> <code>int</code> <p>number of samples taken per year.</p> required <code>time_out</code> <code>ndarray</code> <p>the time values at which to bin the data at.</p> required <code>growth</code> <code>ndarray</code> <p>the growth season with which to bin the data with respect to.</p> required <p>Returns:</p> Type Description <code>DeviceArray</code> <p>The final binned data accounting for both growth season and Schulman's convention.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data is not one-dimensional or in a single row.</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.compile","title":"<code>compile()</code>","text":"<p>Method which compiles crucial parts of the model. If the model has not been compiled before then it compiles the following quantities: - 12C reservoir content of the nodes (in the order the nodes were added) - the fluxes (where fluxes at index (i,j) represents the flux from node[i] to node[j]) - the decay matrix (matrix with decay constant along the diagonal) - production coefficients of the nodes. - the corrected fluxes (fluxes in unit 'Gt/yr') - the matrix of the coefficients for the ODEINT to solve. It also detects if the incoming and outgoing fluxes at every node is balanced and if not then throws ValueError along with which node is unbalanced.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the incoming flux and outgoing flux at every Box is not balanced.</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.equilibrate","title":"<code>equilibrate(target_C_14=None, production_rate=None)</code>","text":"<p>External equilibrate method which determines the appropriate result to return given a parameter. If neither parameter is given then it throws a ValueError. If both are specified, then it ignores production_rate.</p> <p>Parameters:</p> Name Type Description Default <code>target_C_14</code> <code>float</code> <p>target C14 with which to equilibrate with. Defaults to None.</p> <code>None</code> <code>production_rate</code> <code>float</code> <p>production rate with which to equilibrate to. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>float | ndarray</code> <p>if target C14 is specified, it returns the initial production rate. If the production rate is specified, then it returns a ndarray of the C14 reservoir content.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the both arguments are specified as None.</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.get_converted_fluxes","title":"<code>get_converted_fluxes()</code>","text":"<p>Getter method for the fluxes when converted to 'Gt/yr' (this is the unit that the rest of the methods work     in internally). This returns None if the compile method has not been run.</p> <p>Returns:</p> Type Description <code>DeviceArray</code> <p>2D jax numpy array which contains the unit-corrected fluxes where index (i,j) indicates the 'Gt/yr' flux from node[i] to node[j].</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.get_edges","title":"<code>get_edges()</code>","text":"<p>Getter method for the name of edges.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of the edges (given in their string representations i.e. str(source) --&gt; str(destination):flux_value).</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.get_edges_objects","title":"<code>get_edges_objects()</code>","text":"<p>Getter method for the edge objects themselves.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of Flow Objects that have been added so far to the Class Object.</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.get_fluxes","title":"<code>get_fluxes()</code>","text":"<p>Getter method for the compiled fluxes in the units specified in the init_method. If the compile method has     not been run, then it will return None.</p> <p>Returns:</p> Type Description <code>DeviceArray</code> <p>2D jax numpy array which contains the fluxes where index (i,j) indicates the flux from node[i] to node[j].</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.get_matrix","title":"<code>get_matrix()</code>","text":"<p>Getter method for the ODE coefficient matrix to solve.</p> <p>Returns:</p> Type Description <code>DeviceArray</code> <p>jax array of the ODE coefficient matrix to solve.</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.get_nodes","title":"<code>get_nodes()</code>","text":"<p>Getter method for the name of the nodes in the order they were added to the Carbon Box Model Object.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of node names in the order they were inserted.</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.get_nodes_objects","title":"<code>get_nodes_objects()</code>","text":"<p>Getter method for the node objects in the order they were inserted.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of the node objects in the order they were inserted.</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.get_production_coefficients","title":"<code>get_production_coefficients()</code>","text":"<p>Getter method for the normalised production coefficients of the nodes (Boxes). Returns None if compile method has not been called.</p> <p>Returns:</p> Type Description <code>DeviceArray</code> <p>jax array containing the normalised production coefficients of the nodes (returned in the order the nodes were added).</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.get_reservoir_contents","title":"<code>get_reservoir_contents()</code>","text":"<p>Getter method for the 12C reservoir content of the nodes (Boxes).. Returns None if the compile method has not been called.</p> <p>Returns:</p> Type Description <code>DeviceArray</code> <p>jax numpy array containing the reservoir content of the nodes (returned in the order the nodes were added).</p>"},{"location":"cbm_api/#ticktack.ticktack.CarbonBoxModel.run","title":"<code>run(time, production, y0=None, args=(), target_C_14=None, steady_state_production=None, solution=None, adaptive=True, step_ts=None)</code>","text":"<p>For the given production function, this calculates the C14 content of all the boxes within the carbon box model at the specified time values. It does this by solving a linear system of ODEs. This method will not work if the compile method has not been executed first.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>list</code> <p>the time values at which to calculate the content of all the boxes.</p> required <code>production</code> <code>callable</code> <p>the production function which determines the contents of the boxes.</p> required <code>y0</code> <code>list</code> <p>the initial contents of all boxes. Defaults to None. Must be a length(n) list of the same size as the number of boxes.</p> <code>None</code> <code>args</code> <code>tuple</code> <p>optional arguments to pass into the production function.</p> <code>()</code> <code>steady_state_production</code> <code>int</code> <p>the steady state production rate with which to equilibrate with to find steady state solution. If y0 is specified, this parameter is ignored.</p> <code>None</code> <code>target_C_14</code> <code>int</code> <p>target C14 with which to equilibrate with to find steady state solution. If y0 or steady_state_production is  specified, this parameter is ignored.</p> <code>None</code> <code>solution</code> <code>ndarray</code> <p>the equilibrium solution to the ODE system. If this is not specified, then it will be calculated internally. Must be of the same length as the number of boxes.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[list, list]</code> <p>The value of each box in the carbon box at the specified time_values along with the steady state solution for the system.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither the target C-14 nor production rate is specified. If the production is not a callable function.</p>"},{"location":"cf_api/","title":"Documentation for <code>CarbonFitter</code>","text":"<p>Parent class of SingleFitter and MultiFitter. Does Monte Carlo sampling, plotting and more.</p>"},{"location":"cf_api/#ticktack.fitting.CarbonFitter.MarkovChainSampler","title":"<code>MarkovChainSampler(params, likelihood, burnin=500, production=1000, k=2, args=())</code>","text":"<p>Runs an affine-invariant MCMC sampler on an array of initial parameters, subject to some likelihood function.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>Initial parameters for MC sampler</p> required <code>likelihood</code> <code>callable</code> <p>Log-likelihood function for params</p> required <code>burnin</code> <code>int</code> <p>Number of steps to run in burn-in period. 500 by default.</p> <code>500</code> <code>production</code> <code>int</code> <p>Number of steps to run in production period. 1000 by default.</p> <code>1000</code> <code>k</code> <p>Number of walkers per parameter. 2 by default.</p> <code>2</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A chain of MCMC walk</p>"},{"location":"cf_api/#ticktack.fitting.CarbonFitter.chain_summary","title":"<code>chain_summary(chain, walkers, figsize=(10, 10), labels=None, plot_dist=False, test_convergence=False, label_font_size=8, tick_font_size=8, mle=False, usetex=False)</code>","text":"<p>Runs convergence tests and plots posteriors from a MCMC chain.</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>ndarray</code> <p>A MCMC chain</p> required <code>walkers</code> <code>int</code> <p>The total number of walkers of the chain</p> required <code>figsize</code> <code>tuple</code> <p>Output figure size</p> <code>(10, 10)</code> <code>labels</code> <code>list[str]</code> <p>A list of parameter names</p> <code>None</code> <code>plot_dist</code> <code>bool</code> <p>If True, plot the marginal distributions of parameters. Else, plot both the marginal distribution  and the posterior surface</p> <code>False</code>"},{"location":"cf_api/#ticktack.fitting.CarbonFitter.correlation_plot","title":"<code>correlation_plot(array, figsize=10, square_size=100)</code>","text":"<p>Makes an accessible heatmap for visualizing correlation/covariance matrix.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>n x n matrix</p> required <code>figsize</code> <code>int</code> <p>Output figure size. 10 by default</p> <code>10</code> <code>square_size</code> <p>Size of squares on the heatmap. 100 by default</p> <code>100</code> <p>Returns:</p> Type Description <code>figure</code> <p>heatmap</p>"},{"location":"cf_api/#ticktack.fitting.CarbonFitter.plot_multiple_chains","title":"<code>plot_multiple_chains(chains, walker, figsize=(10, 10), title=None, params_labels=None, labels=None, colors=None, alpha=0.5, linewidths=None, plot_dists=False, label_font_size=12, tick_font_size=8, max_ticks=10, legend=True, usetex=False, truth=None)</code>","text":"<p>Overplots posterior surfaces from multiple chains.  Parameters</p> <p>chains : list      List of MCMC chains  walker : int      Number of walkers for each chain in 'chains'  figsize : tuple, optional      Output figure size  params_labels : list[str], optional      List of parameter names  labels : list[str], optional      List of labels for different chains  colors : list[str], optional      List of colors  alpha : float, optional      Parameter for blending, between 0-1.  linewidths : float, optional      Line width, in points  plot_dists : bool, optional      If True, only plot the marginal distributions of parameters  label_font_size : int, optional      Label font size  tick_font_size : int, optional      Tick font size  max_ticks : int, optional      Maximum number of ticks allowed  legend : bool, optional      If True, adds a legend  Returns</p> <p>figure      plot of posterior surfaces or marginal distributions</p>"},{"location":"data/","title":"Datasets","text":"<p>This repository comes packaged with all datasets used in the Zhang et al, 2022 first science paper using <code>ticktack</code>. These data are publicly available, and necessary to reproduce figures in the aforementioned paper and the accompanying Sharma et al JOSS paper.</p> <p>Under <code>src/ticktack/data/datasets/</code> these are listed, by event, as <code>.csv</code> files.</p>"},{"location":"data/#references","title":"References","text":"<p>Datsets have filenames labelled by provenance:</p> <ul> <li><code>Buntgen18*</code>: the COSMIC sample, from B\u00fcntgen U., et al., 2018, Nature Communications, 9, 3605</li> <li><code>Scifo19*</code>: Scifo A., et al., 2019, Scientific Reports, 9, 17056</li> <li><code>Sakurai20*</code>: Sakurai H., et al., 2020</li> <li><code>Brehm21*</code>: are from Brehm N., et al., 2021, Nature Geoscience, 14, 10.</li> <li><code>Miyake21*</code>: Miyake F., et al., 2021, Geophys. Res. Lett., 48, e93419</li> </ul>"},{"location":"fitting_api/","title":"Documentation for <code>fitting</code>","text":""},{"location":"fitting_api/#ticktack.fitting.get_data","title":"<code>get_data(path=None)</code>","text":"<p>Retrieves the names of all data files in a directory</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to a directory where data files are stored</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of file names</p>"},{"location":"fitting_api/#ticktack.fitting.sample_event","title":"<code>sample_event(year, mf, sampler='MCMC', production_model='simple_sinusoid', burnin=500, production=1000, params=None, low_bounds=None, up_bounds=None)</code>","text":"<p>Runs a Monte Carlo sampler on some data files.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>float</code> <p>The calender year of the event</p> required <code>mf</code> <code>MultiFitter</code> <p>A compiled MultiFitter</p> required <code>sampler</code> <code>str</code> <p>Monte Carlo sampler. 'MCMC' for Markov Chain Monte Carlo, 'NS' for Nested Sampling. 'MCMC' by default.</p> <code>'MCMC'</code> <code>production_model</code> <code>str | callable</code> <p>Production rate model. 'simple_sinusoid' by default.</p> <code>'simple_sinusoid'</code> <code>burnin</code> <code>int</code> <p>Number of burn-in steps for Markov Chain Monte Carlo, 500 by default.</p> <code>500</code> <code>production</code> <code>int</code> <p>Number of production steps for Markov Chain Monte Carlo, 1000 by default.</p> <code>1000</code> <code>params</code> <code>ndarray</code> <p>Initial parameters for Monte Carlo samplers. Required when custom production rate model is used.</p> <code>None</code> <code>low_bounds</code> <code>ndarray</code> <p>Lower bound of params. Required when custom production rate model is used.</p> <code>None</code> <code>up_bounds</code> <code>ndarray</code> <p>Upper bound of params. Required when custom production rate model is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Monte Carlo samples</p>"},{"location":"fitting_api/#ticktack.fitting.fit_event","title":"<code>fit_event(year, path=None, production_model='simple_sinusoid', cbm_model='Guttler15', box='Troposphere', hemisphere='north', sampler=None, burnin=500, production=1000, params=None, low_bounds=None, up_bounds=None, mf=None, oversample=1008, burnin_time=2000, verbose=False)</code>","text":"<p>Fits a Miyake event.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>float</code> <p>The calender year of the event</p> required <code>mf</code> <code>MultiFitter</code> <p>A compiled MultiFitter</p> <code>None</code> <code>cbm_model</code> <code>str</code> <p>Name of a Carbon Box Model. Must be one in: Miyake17, Brehm21, Guttler15, Buntgen18.</p> <code>'Guttler15'</code> <code>oversample</code> <code>int</code> <p>Number of samples per year in production. 1008 by default</p> <code>1008</code> <code>burnin_time</code> <code>int</code> <p>Number of years in the burn-in period. 2000 by default</p> <code>2000</code> <code>sampler</code> <code>str</code> <p>Monte Carlo sampler. 'MCMC' for Markov Chain Monte Carlo, 'NS' for Nested Sampling. 'MCMC' by default.</p> <code>None</code> <code>box</code> <code>str</code> <p>Box for calculating d14c. 'Troposphere' by default</p> <code>'Troposphere'</code> <code>hemisphere</code> <code>str</code> <p>CBM hemisphere. Must be one in: \"north\", \"south\". \"north\" by default</p> <code>'north'</code> <code>production_model</code> <code>str | callable</code> <p>Production rate model. 'simple_sinusoid' by default.</p> <code>'simple_sinusoid'</code> <code>burnin</code> <code>int</code> <p>Number of burn-in steps for Markov Chain Monte Carlo, 500 by default.</p> <code>500</code> <code>production</code> <code>int</code> <p>Number of production steps for Markov Chain Monte Carlo, 1000 by default.</p> <code>1000</code> <code>params</code> <code>ndarray</code> <p>Initial parameters for Monte Carlo samplers. Required when custom production rate model is used.</p> <code>None</code> <code>low_bounds</code> <code>ndarray</code> <p>Lower bound of params. Required when custom production rate model is used.</p> <code>None</code> <code>up_bounds</code> <code>ndarray</code> <p>Upper bound of params. Required when custom production rate model is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>mf</code> <code>MultiFitter</code> <p>A compile MultiFitter object</p> <code>chain</code> <code>ndrray | NestedSampler object</code> <p>Monte Carlo samples</p>"},{"location":"flow_api/","title":"Documentation for <code>Flow</code>","text":"<p>Flow class to imitate the fluxes between boxes in a carbon box model.</p>"},{"location":"flow_api/#ticktack.ticktack.Flow.__init__","title":"<code>__init__(source, destination, flux_rate)</code>","text":"<p>Init method to initialise object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Box</code> <p>source of the flow.</p> required <code>destination</code> <code>Box</code> <p>destination the flow.</p> required <code>flux_rate</code> <code>float</code> <p>flux rate between the source and the destination. Flux must be a non-negative value.</p> required"},{"location":"flow_api/#ticktack.ticktack.Flow.get_source","title":"<code>get_source()</code>","text":"<p>Getter method for the source node of the Flow Class.</p> <p>Returns:</p> Type Description <code>Box</code> <p>source of flow.</p>"},{"location":"flow_api/#ticktack.ticktack.Flow.get_destination","title":"<code>get_destination()</code>","text":"<p>Getter method for the destination node of the Flow Class.</p> <p>Returns:</p> Type Description <code>Box</code> <p>destination of the flow.</p>"},{"location":"flow_api/#ticktack.ticktack.Flow.get_flux","title":"<code>get_flux()</code>","text":"<p>Getter method for the flux rate of the Flow Class.</p> <p>Returns:</p> Type Description <code>float</code> <p>flux of the flow object.</p>"},{"location":"flow_api/#ticktack.ticktack.Flow.__str__","title":"<code>__str__()</code>","text":"<p>Overrides the default string behaviour to display a user-friendly output.</p> <p>Returns:</p> Type Description <code>str</code> <p>string representation of the Flow Object returned in the following form - str(source)--&gt;str(destination):flux_value</p>"},{"location":"mf_api/","title":"Documentation for <code>MultiFitter</code>","text":"<p>             Bases: <code>CarbonFitter</code></p> <p>A class for parametric inference of d14c data from a common time period using an ensemble of SingleFitter. Does parameter fitting, likelihood evaluations, Monte Carlo sampling, plotting and more.</p>"},{"location":"mf_api/#ticktack.fitting.MultiFitter.MultiFitter","title":"<code>MultiFitter = []</code>  <code>instance-attribute</code>","text":""},{"location":"mf_api/#ticktack.fitting.MultiFitter.__init__","title":"<code>__init__(adaptive=True)</code>","text":"<p>Initializes a MultiFitter object.</p>"},{"location":"mf_api/#ticktack.fitting.MultiFitter.add_SingleFitter","title":"<code>add_SingleFitter(sf)</code>","text":"<p>Adds a SingleFitter object to a Multifitter object.</p> <p>Parameters:</p> Name Type Description Default <code>sf</code> <code>SingleFitter</code> <p>SingleFitter Object</p> required"},{"location":"mf_api/#ticktack.fitting.MultiFitter.compile","title":"<code>compile()</code>","text":"<p>Prepares a Multifitter object for d14c computation and likelihood evaluation.</p>"},{"location":"mf_api/#ticktack.fitting.MultiFitter.multi_interp_gp","title":"<code>multi_interp_gp(tval, *args)</code>","text":"<p>A Gaussian Process regression interpolator for MultiFitter.</p> <p>Parameters:</p> Name Type Description Default <code>tval</code> <code>ndarray</code> <p>Output time sampling</p> required <code>args</code> <code>ndarray | float</code> <p>Set of annually resolved control-points</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Interpolated values on tval</p>"},{"location":"mf_api/#ticktack.fitting.MultiFitter.super_gaussian","title":"<code>super_gaussian(t, start_time, duration, area)</code>","text":"<p>Computes the density of a super gaussian of exponent 16. Used to emulates the spike in d14c data following the occurrence of a Miyake event.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>Time sampling</p> required <code>start_time</code> <code>float</code> <p>Start time of a Miyake event</p> required <code>duration</code> <code>float</code> <p>Duration of a Miyake event</p> required <code>area</code> <code>float</code> <p>Total radiocarbon delivered by a Miyake event</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Production rate on t</p>"},{"location":"mf_api/#ticktack.fitting.MultiFitter.flexible_sinusoid_affine_variant","title":"<code>flexible_sinusoid_affine_variant(t, *args)</code>","text":"<p>A flexible sinusoid production rate model with a linear gradient. Tunable parameters are, Gradient: linear gradient</p> <p>Start time: start time</p> <p>log_Duration: log10 duration</p> <p>Phase: phase of the solar cycle</p> <p>log_Area: log10 total radiocarbon delivered</p> <p>log_Amplitude: log10 solar amplitude</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>Time sampling</p> required <code>args</code> <code>ndarray</code> <p>Tunable parameters. Must include, gradient, start time, duration, phase, area and amplitude</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Production rate on t</p>"},{"location":"mf_api/#ticktack.fitting.MultiFitter.run_burnin","title":"<code>run_burnin(y0=None, params=())</code>","text":"<p>Calculates the C14 content of all the boxes within a CBM for the burn-in period.</p> <p>Parameters:</p> Name Type Description Default <code>y0</code> <code>ndarray</code> <p>Initial contents of all boxes</p> <code>None</code> <code>params</code> <code>ndarray</code> <p>Parameters for the production rate model</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Value of each box in the CBM during the burn-in period</p>"},{"location":"mf_api/#ticktack.fitting.MultiFitter.run_event","title":"<code>run_event(y0=None, params=())</code>","text":"<p>Calculates the C14 content of all the boxes within a CBM for the production period.</p> <p>Parameters:</p> Name Type Description Default <code>y0</code> <code>ndarray</code> <p>The initial contents of all boxes</p> <code>None</code> <code>params</code> <code>ndarray</code> <p>Parameters for self.production function</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Value of each box in the CBM during the production period</p>"},{"location":"mf_api/#ticktack.fitting.MultiFitter.dc14_fine","title":"<code>dc14_fine(params=())</code>","text":"<p>Predict d14c on a sub-annual time sampling.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>Parameters for the production rate model</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Predicted d14c value</p>"},{"location":"mf_api/#ticktack.fitting.MultiFitter.multi_likelihood","title":"<code>multi_likelihood(params)</code>","text":"<p>Computes the ensemble log-likelihood of the parameters of self.production across multiple d14c datasets</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>Parameters of self.production</p> required <p>Returns:</p> Type Description <code>float</code> <p>Log-likelihood</p>"},{"location":"mf_api/#ticktack.fitting.MultiFitter.log_likelihood_gp","title":"<code>log_likelihood_gp(params)</code>","text":"<p>Computes the Gaussian Process log-likelihood of a set of control-points. The Gaussian Process has a constant mean and a Matern-3/2 kernel with 1 year scale parameter.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>An array of control-points. The first control point is also the mean of the Gaussian Process</p> required <p>Returns:</p> Type Description <code>float</code> <p>Gaussian Process log-likelihood</p>"},{"location":"mf_api/#ticktack.fitting.MultiFitter.log_joint_likelihood","title":"<code>log_joint_likelihood(params, low_bounds, up_bounds)</code>","text":"<p>Computes the log joint likelihood of production rate model parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>Production rate model parameters</p> required <code>low_bounds</code> <code>ndarray</code> <p>Lower bound of params</p> required <code>up_bounds</code> <code>ndarray</code> <p>Upper bound of params</p> required <p>Returns:</p> Type Description <code>float</code> <p>Log joint likelihood</p>"},{"location":"mf_api/#ticktack.fitting.MultiFitter.neg_log_joint_likelihood_gp","title":"<code>neg_log_joint_likelihood_gp(params)</code>","text":"<p>Computes the negative log joint likelihood of a set of control-points. Used as the objective function for fitting the set of control-points via numerical optimization.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>An array of control-points</p> required <p>Returns:</p> Type Description <code>float</code> <p>Negative log joint likelihood</p>"},{"location":"mf_api/#ticktack.fitting.MultiFitter.fit_ControlPoints","title":"<code>fit_ControlPoints(low_bound=0)</code>","text":"<p>Fits the control-points by minimizing the negative log joint likelihood.</p> <p>Parameters:</p> Name Type Description Default <code>low_bound</code> <code>int</code> <p>The minimum value each control-point can take. 0 by default.</p> <code>0</code> <p>Returns:</p> Type Description <code>OptimizeResult</code> <p>Scipy OptimizeResult object</p>"},{"location":"sf_api/","title":"Documentation for <code>SingleFitter</code>","text":"<p>             Bases: <code>CarbonFitter</code></p> <p>A class for parametric and non-parametric inference of d14c data using a Carbon Box Model (CBM). Does parameter fitting, Monte Carlo sampling, plotting and more.</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.__init__","title":"<code>__init__(cbm, cbm_model, production_rate_units='atoms/cm^2/s', target_C_14=707.0, box='Troposphere', hemisphere='north', adaptive=True)</code>","text":"<p>Initializes a SingleFitter Object.</p> <p>Parameters:</p> Name Type Description Default <code>cbm</code> <code>CarbonBoxModel Object</code> <p>Carbon Box Model</p> required <code>cbm_model</code> <code>str</code> <p>CBM name. Must be one in: \"Guttler15\", \"Miyake17\", \"Buntgen18\", \"Brehm21\"</p> required <code>production_rate_units</code> <code>str</code> <p>CBM production rate units. 'atoms/cm^2/s' by default</p> <code>'atoms/cm^2/s'</code> <code>target_C_14</code> <code>float</code> <p>Target 14C content for equilibration. 707 by default</p> <code>707.0</code> <code>box</code> <code>str</code> <p>Box for calculating d14c. 'Troposphere' by default</p> <code>'Troposphere'</code> <code>hemisphere</code> <code>str</code> <p>CBM hemisphere. Must be one in: \"north\", \"south\". \"north\" by default</p> <code>'north'</code>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.load_data","title":"<code>load_data(file_name, oversample=1008, burnin_oversample=1, burnin_time=2000, num_offset=4, verbose=False)</code>","text":"<p>Loads d14c data from a csv file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Path to a csv file</p> required <code>oversample</code> <code>int</code> <p>Number of samples per year in production. 1008 by default</p> <code>1008</code> <code>burnin_oversample</code> <code>int</code> <p>Number of samples per year in burn-in. 1 by default</p> <code>1</code> <code>burnin_time</code> <code>int</code> <p>Number of years in the burn-in period. 2000 by default</p> <code>2000</code> <code>num_offset</code> <code>int</code> <p>Number of data points used for normalization. 4 by default</p> <code>4</code>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.get_growth_vector","title":"<code>get_growth_vector(growth_season)</code>","text":"<p>Converts the growing season of a tree from string to 12-digit binary vector.</p> <p>Parameters:</p> Name Type Description Default <code>growth_season</code> <code>str</code> <p>Growing season. Must have the format: \"StartMonth-EndMonth\"</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>12-digit binary vector</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.compile_production_model","title":"<code>compile_production_model(model=None)</code>","text":"<p>Sets the production rate model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str | callable</code> <p>Built-in or custom model. Supported built-in model are: \"simple_sinusoid\", \"flexible_sinusoid\", \"flexible_sinusoid_affine_variant\", \"control_points\", \"inverse_solver\"</p> <code>None</code>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.interp_gp","title":"<code>interp_gp(tval, *args)</code>","text":"<p>A Gaussian Process regression interpolator.</p> <p>Parameters:</p> Name Type Description Default <code>tval</code> <code>ndarray</code> <p>Output time sampling</p> required <code>args</code> <code>ndarray | float</code> <p>Set of annually resolved control-points passed in as a ndarray</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Interpolation on tval</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.interp_IS","title":"<code>interp_IS(tval, *args)</code>","text":"<p>A linear interpolator for inverse solver.</p> <p>Parameters:</p> Name Type Description Default <code>tval</code> <code>ndarray</code> <p>Output time sampling</p> required <code>args</code> <code>ndarray | float</code> <p>Set of production rates on the same time sampling as self.time_data</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Interpolation on tval</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.super_gaussian","title":"<code>super_gaussian(t, start_time, duration, area)</code>","text":"<p>Computes the density of a super gaussian of exponent 16. Used to emulates the spike in d14c data following the occurrence of a Miyake event.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>Time sampling</p> required <code>start_time</code> <code>float</code> <p>Start time of a Miyake event</p> required <code>duration</code> <code>float</code> <p>Duration of a Miyake event</p> required <code>area</code> <code>float</code> <p>Total radiocarbon delivered by a Miyake event</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Production rate on t</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.simple_sinusoid","title":"<code>simple_sinusoid(t, *args)</code>","text":"<p>A simple sinusoid production rate model. Tunable parameters are, Start time: start time</p> <p>log_Duration: log10 duration</p> <p>Phase: phase of the solar cycle</p> <p>log_Area: log10 total radiocarbon delivered</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>Time sampling</p> required <code>args</code> <code>ndarray</code> <p>Tunable parameters. Must include, start time, duration, phase and area</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Production rate on t</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.flexible_sinusoid","title":"<code>flexible_sinusoid(t, *args)</code>","text":"<p>A flexible sinusoid production rate model. Tunable parameters are, Start time: start time</p> <p>log_Duration: log10 duration</p> <p>Phase: phase of the solar cycle</p> <p>log_Area: log10 total radiocarbon delivered</p> <p>log_Amplitude: log10 solar amplitude</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>Time sampling</p> required <code>args</code> <code>ndarray</code> <p>Tunable parameters. Must include, start time, duration, phase, area and amplitude</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Production rate on t</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.flexible_sinusoid_affine_variant","title":"<code>flexible_sinusoid_affine_variant(t, *args)</code>","text":"<p>A flexible sinusoid production rate model with a linear gradient. Tunable parameters are, Gradient: linear gradient</p> <p>Start time: start time</p> <p>log_Duration: log10 duration</p> <p>Phase: phase of the solar cycle</p> <p>log_Area: log10 total radiocarbon delivered</p> <p>log_Amplitude: log10 solar amplitude</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>Time sampling</p> required <code>args</code> <code>ndarray</code> <p>Tunable parameters. Must include, gradient, start time, duration, phase, area and amplitude</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Production rate on t</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.run_burnin","title":"<code>run_burnin(y0=None, params=())</code>","text":"<p>Calculates the C14 content of all the boxes within a CBM for the burn-in period.</p> <p>Parameters:</p> Name Type Description Default <code>y0</code> <code>ndarray</code> <p>Initial contents of all boxes</p> <code>None</code> <code>params</code> <code>ndarray</code> <p>Parameters for the production rate model</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Value of each box in the CBM during the burn-in period</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.run_event","title":"<code>run_event(y0=None, params=())</code>","text":"<p>Calculates the C14 content of all the boxes within a CBM for the production period.</p> <p>Parameters:</p> Name Type Description Default <code>y0</code> <code>ndarray</code> <p>The initial contents of all boxes</p> <code>None</code> <code>params</code> <code>ndarray</code> <p>Parameters for self.production function</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Value of each box in the CBM during the production period</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.dc14","title":"<code>dc14(params=())</code>","text":"<p>Predict d14c on the time sampling from the data file.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>Parameters for the production rate model</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Predicted d14c value</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.dc14_fine","title":"<code>dc14_fine(params=())</code>","text":"<p>Predict d14c on a sub-annual time sampling.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>Parameters for the production rate model</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Predicted d14c value</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.log_likelihood","title":"<code>log_likelihood(params=())</code>","text":"<p>Computes the gaussian log-likelihood of production rate model parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>Parameters of the production rate model</p> <code>()</code> <p>Returns:</p> Type Description <code>float</code> <p>Gaussian log-likelihood</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.log_joint_likelihood","title":"<code>log_joint_likelihood(params, low_bounds, up_bounds)</code>","text":"<p>Computes the log joint likelihood of production rate model parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>Production rate model parameters</p> required <code>low_bounds</code> <code>ndarray</code> <p>Lower bound of params</p> required <code>up_bounds</code> <code>ndarray</code> <p>Upper bound of params</p> required <p>Returns:</p> Type Description <code>float</code> <p>Log joint likelihood</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.log_likelihood_gp","title":"<code>log_likelihood_gp(params)</code>","text":"<p>Computes the Gaussian Process log-likelihood of a set of control-points. The Gaussian Process has a constant mean and a Matern-3/2 kernel with 1 year scale parameter.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>An array of control-points. The first control point is also the mean of the Gaussian Process</p> required <p>Returns:</p> Type Description <code>float</code> <p>Gaussian Process log-likelihood</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.log_joint_likelihood_gp","title":"<code>log_joint_likelihood_gp(params, low_bounds, up_bounds)</code>","text":"<p>Computes the log joint likelihood of a set of control-points.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>An array of control-points</p> required <p>Returns:</p> Type Description <code>float</code> <p>Log joint likelihood</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.neg_log_joint_likelihood_gp","title":"<code>neg_log_joint_likelihood_gp(params)</code>","text":"<p>Computes the negative log joint likelihood of a set of control-points. Used as the objective function for fitting the set of control-points via numerical optimization.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>An array of control-points</p> required <p>Returns:</p> Type Description <code>float</code> <p>Negative log joint likelihood</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.grad_neg_log_joint_likelihood_gp","title":"<code>grad_neg_log_joint_likelihood_gp(params=())</code>","text":"<p>Computes the negative gradient of the log joint likelihood of a set of control-points.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>An array of control-points</p> <code>()</code> <p>Returns:</p> Type Description <code>float</code> <p>Negative gradient of log joint likelihood</p>"},{"location":"sf_api/#ticktack.fitting.SingleFitter.fit_ControlPoints","title":"<code>fit_ControlPoints(low_bound=0)</code>","text":"<p>Fits control-points by minimizing the negative log joint likelihood.</p> <p>Parameters:</p> Name Type Description Default <code>low_bound</code> <code>int</code> <p>The minimum value each control-point can take. 0 by default.</p> <code>0</code> <p>Returns:</p> Type Description <code>OptimizeResult</code> <p>Scipy OptimizeResult object</p>"},{"location":"ticktack_api/","title":"Documentation for <code>ticktack</code>","text":""},{"location":"ticktack_api/#ticktack.ticktack.save_model","title":"<code>save_model(carbon_box_model, filename)</code>","text":"<p>Saves the Carbon Box Model in a hd5 format with the specified filename. If the first parameter is not of Type CarbonBoxModel, then it throws a ValueError.</p> <p>Parameters:</p> Name Type Description Default <code>carbon_box_model</code> <code>CarbonBoxModel</code> <p>the model to save.</p> required <code>filename</code> <code>str</code> <p>file name and location where Carbon Box Model needs to be saved. Must have a '.hd5' at end of filename.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the first parameter is not of type CarbonBoxModel.</p>"},{"location":"ticktack_api/#ticktack.ticktack.load_model","title":"<code>load_model(filename, production_rate_units='kg/yr', flow_rate_units='Gt/yr')</code>","text":"<p>Loads the saved Carbon Box Model from the relevant filename. Units for both production rate and flow rate can be specified as parameters. filename must be specified with the .hd5 extension.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the name and location (in one string) of the file where the Carbon Box Model is saved.</p> required <code>production_rate_units</code> <code>str</code> <p>the production rate of the model to be loaded. Defaults to 'kg/yr'.</p> <code>'kg/yr'</code> <code>flow_rate_units</code> <code>str</code> <p>the production rate of the model to be loaded. Defaults to 'Gt/yr'.</p> <code>'Gt/yr'</code> <p>Returns:</p> Type Description <code>CarbonBoxModel</code> <p>Carbon Box Model which is generated from the file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the flow rate units are not either 'Gt/yr' or '1/yr'.</p>"},{"location":"ticktack_api/#ticktack.ticktack.load_presaved_model","title":"<code>load_presaved_model(model, production_rate_units='kg/yr', flow_rate_units='Gt/yr')</code>","text":"<p>Loads a pre-saved, commonly used model based on the research papers linked below. The model must be one of the following: Miyake17, Brehm21, Guttler15, Buntgen18. Loads the model based on the units for production rate and flow rate specified.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>the name of the model to load. Must be one in [Miyake17, Brehm21, Guttler15, Buntgen18].</p> required <code>production_rate_units</code> <code>str</code> <p>the production rate of the model to be loaded. Defaults to 'kg/yr'.</p> <code>'kg/yr'</code> <code>flow_rate_units</code> <code>str</code> <p>the production rate of the model to be loaded. Defaults to 'Gt/yr'.</p> <code>'Gt/yr'</code> <p>Returns:</p> Type Description <code>CarbonBoxModel</code> <p>Carbon Box Model which is generated from the pre-saved file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified model parameter is not in the required list.</p>"},{"location":"notebooks/01_Fitting/","title":"Fitting with ticktack and emcee","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nimport ticktack\nfrom ticktack import fitting\n\nfrom tqdm import tqdm\nfrom matplotlib.lines import Line2D\n\nfrom chainconsumer import ChainConsumer, Chain, PlotConfig\n\nimport pandas as pd\n</pre> import numpy as np import matplotlib.pyplot as plt  import ticktack from ticktack import fitting  from tqdm import tqdm from matplotlib.lines import Line2D  from chainconsumer import ChainConsumer, Chain, PlotConfig  import pandas as pd  <p>Now, we load a presaved model; <code>ticktack</code> currently has pre-saved reimplementations of the carbon box models from 'Guttler15', 'Brehm21', 'Miyake17', or 'Buntgen18'.</p> In\u00a0[2]: Copied! <pre>cbm = ticktack.load_presaved_model(\"Guttler15\", production_rate_units = \"atoms/cm^2/s\")\n</pre> cbm = ticktack.load_presaved_model(\"Guttler15\", production_rate_units = \"atoms/cm^2/s\") <p>Now we initialize a <code>SingleFitter</code> object using this carbon box model, together with the data from Miyake et al, 2012. This will handle Bayesian inference of production rates conditioned on these data.</p> In\u00a0[3]: Copied! <pre>sf = fitting.SingleFitter(cbm, cbm_model=\"Guttler15\")\nsf.load_data(\"miyake12.csv\")\nsf.compile_production_model(model=\"simple_sinusoid\")\n</pre> sf = fitting.SingleFitter(cbm, cbm_model=\"Guttler15\") sf.load_data(\"miyake12.csv\") sf.compile_production_model(model=\"simple_sinusoid\") In\u00a0[4]: Copied! <pre>sf.time_offset\n</pre> sf.time_offset Out[4]: <pre>0.4583333333333333</pre> <p>The default engine for sampling from this posterior is emcee. We are working on implementing nested sampling and variational inference. We call <code>emcee</code> from a method of the <code>SingleFitter</code> object like this, where params are (arrival time in years, duration in years, solar cycle phase in years, and total radiocarbon delivered in production rate times years).</p> In\u00a0[5]: Copied! <pre>%%time\ndefault_params = np.array([775., np.log10(1./12), np.pi/2., np.log10(81./12)]) # start date, duration, phase, area\nsampler = sf.MarkovChainSampler(default_params, \n                                likelihood = sf.log_joint_likelihood, \n                                burnin = 500, \n                                production = 500, \n                                args = (np.array([770., np.log10(1/52.), 0, -2]), # lower bound\n                                np.array([780., np.log10(5.), 11, 1.5]))         # upper bound \n                               )\nsamples = sampler.copy()\nsamples[:,1] = 10**samples[:,1] # duration not log duration\nsamples[:,-1] = 10**samples[:,-1] # area not log area\n</pre> %%time default_params = np.array([775., np.log10(1./12), np.pi/2., np.log10(81./12)]) # start date, duration, phase, area sampler = sf.MarkovChainSampler(default_params,                                  likelihood = sf.log_joint_likelihood,                                  burnin = 500,                                  production = 500,                                  args = (np.array([770., np.log10(1/52.), 0, -2]), # lower bound                                 np.array([780., np.log10(5.), 11, 1.5]))         # upper bound                                 ) samples = sampler.copy() samples[:,1] = 10**samples[:,1] # duration not log duration samples[:,-1] = 10**samples[:,-1] # area not log area <pre>Running burn-in...\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:59&lt;00:00,  8.41it/s]\n</pre> <pre>Running production...\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:58&lt;00:00,  8.56it/s]</pre> <pre>CPU times: user 1min 57s, sys: 3.23 s, total: 2min 1s\nWall time: 1min 59s\n</pre> <pre>\n</pre> <p>Plot of posterior surface using ChainConsumer:</p> In\u00a0[8]: Copied! <pre>labels = [\"Start Date (yr)\", \"Duration (yr)\", \"phi (yr)\", \"Q (atoms/cm$^2$ yr/s)\"]\nfig = sf.chain_summary(samples, 8, labels=labels,label_font_size=10)\n</pre> labels = [\"Start Date (yr)\", \"Duration (yr)\", \"phi (yr)\", \"Q (atoms/cm$^2$ yr/s)\"] fig = sf.chain_summary(samples, 8, labels=labels,label_font_size=10) <p>And a plot of models evaluated from samples of the posterior parameters shows a pretty good fit!</p> In\u00a0[7]: Copied! <pre>fig, (ax1, ax2) = plt.subplots(2, figsize=(8, 8), sharex=True, gridspec_kw={'height_ratios': [2, 1]}, dpi=80)\nfig.subplots_adjust(hspace=0.05)\nplt.rcParams.update({\"text.usetex\": False})\nidx = np.random.randint(len(sampler), size=100)\nfor param in tqdm(sampler[idx]):\n    ax1.plot(sf.time_data_fine, sf.dc14_fine(params=param), alpha=0.05, color=\"g\")\n\nfor param in tqdm(sampler[idx][:30]):\n    ax2.plot(sf.time_data_fine, sf.production(sf.time_data_fine, *param), alpha=0.2, color=\"g\")\n\nax1.errorbar(sf.time_data + sf.time_offset, sf.d14c_data, yerr=sf.d14c_data_error, \n             fmt=\"ok\", capsize=3, markersize=6, elinewidth=3, label=\"$\\Delta^{14}$C data\")\nax1.legend(frameon=False);\nax2.set_ylim(1, 10);\nax1.set_ylabel(\"$\\Delta^{14}$C (\u2030)\")\nax2.set_xlabel(\"Calendar Year\");\nax2.set_ylabel(\"Production rate (atoms cm$^2$s$^{-1}$)\");\n</pre> fig, (ax1, ax2) = plt.subplots(2, figsize=(8, 8), sharex=True, gridspec_kw={'height_ratios': [2, 1]}, dpi=80) fig.subplots_adjust(hspace=0.05) plt.rcParams.update({\"text.usetex\": False}) idx = np.random.randint(len(sampler), size=100) for param in tqdm(sampler[idx]):     ax1.plot(sf.time_data_fine, sf.dc14_fine(params=param), alpha=0.05, color=\"g\")  for param in tqdm(sampler[idx][:30]):     ax2.plot(sf.time_data_fine, sf.production(sf.time_data_fine, *param), alpha=0.2, color=\"g\")  ax1.errorbar(sf.time_data + sf.time_offset, sf.d14c_data, yerr=sf.d14c_data_error,               fmt=\"ok\", capsize=3, markersize=6, elinewidth=3, label=\"$\\Delta^{14}$C data\") ax1.legend(frameon=False); ax2.set_ylim(1, 10); ax1.set_ylabel(\"$\\Delta^{14}$C (\u2030)\") ax2.set_xlabel(\"Calendar Year\"); ax2.set_ylabel(\"Production rate (atoms cm$^2$s$^{-1}$)\"); <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 35.00it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [00:00&lt;00:00, 249.34it/s]\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/01_Fitting/#fitting-with-ticktack-and-emcee","title":"Fitting with <code>ticktack</code> and <code>emcee</code>\u00b6","text":"<p>Let's go through an example of how you would fit the original Miyake event time series from 774 AD (Miyake et al, 2012) using tools from <code>ticktack</code>. First we import everything.</p>"},{"location":"notebooks/02_MultiFitter/","title":"Fitting multiple datasets using MultiFitter","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport ticktack\nimport jax.numpy as jnp\nfrom jax import jit\nfrom ticktack import fitting\nimport matplotlib as mpl\nmpl.style.use('seaborn-colorblind')\n</pre> import numpy as np import matplotlib.pyplot as plt import ticktack import jax.numpy as jnp from jax import jit from ticktack import fitting import matplotlib as mpl mpl.style.use('seaborn-colorblind') <pre>/var/folders/vx/lm_q_1ld7c13_fbqfscs9n4w0000gq/T/ipykernel_59687/2273207293.py:8: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  mpl.style.use('seaborn-colorblind')\n</pre> In\u00a0[2]: Copied! <pre>ls ../../notebooks/775CE/\n</pre> ls ../../notebooks/775CE/ <pre>B\u00fcntgen18_CHN01.csv     B\u00fcntgen18_SWE05.csv     Jull14_Bristlecone.csv\nB\u00fcntgen18_GER01.csv     B\u00fcntgen18_USA02.csv     Miyake12_Cedar.csv\nB\u00fcntgen18_GER07.csv     B\u00fcntgen18_USA11.csv     Rakowski15_Oak.csv\nB\u00fcntgen18_JAP01.csv     B\u00fcntgen18_USA18.csv     Scifo19_Oak.csv\nB\u00fcntgen18_MON03.csv     Guttler15_Kauri.csv\n</pre> <p>First, we need to make a directory and place our datasets inside it. Each dataset should be a csv file, and has the same format as <code>example.csv</code>.</p> In\u00a0[3]: Copied! <pre>mf, sampler = fitting.fit_event(year=775, # the year of the event\n                                path='../../notebooks/775CE/', \n                                production_model=\"simple_sinusoid\", \n                                sampler=\"MCMC\", \n                                params=jnp.array([775.1, -1., 1.6, np.log10(6.5)]),  # start date, duration, phase, area\n                                low_bounds=jnp.array([770., -1.5, 0, -2]),\n                                up_bounds=jnp.array([780., 1.5, 11, 1.5]),\n                                burnin=500, production=500)\n\nsamples = sampler.copy()\nsamples[:,1] = 10**samples[:,1] # duration not log duration\nsamples[:,-1] = 10**samples[:,-1] # area not log area\n</pre> mf, sampler = fitting.fit_event(year=775, # the year of the event                                 path='../../notebooks/775CE/',                                  production_model=\"simple_sinusoid\",                                  sampler=\"MCMC\",                                  params=jnp.array([775.1, -1., 1.6, np.log10(6.5)]),  # start date, duration, phase, area                                 low_bounds=jnp.array([770., -1.5, 0, -2]),                                 up_bounds=jnp.array([780., 1.5, 11, 1.5]),                                 burnin=500, production=500)  samples = sampler.copy() samples[:,1] = 10**samples[:,1] # duration not log duration samples[:,-1] = 10**samples[:,-1] # area not log area <pre>Retrieving data...\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 14/14 [00:00&lt;00:00, 19.84it/s]\n</pre> <pre>Running burn-in...\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [01:58&lt;00:00,  4.20it/s]\n</pre> <pre>Running production...\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [01:56&lt;00:00,  4.28it/s]\n</pre> In\u00a0[4]: Copied! <pre>labels = [\"start date (yr)\", \"duration (yr)\", \"$\\phi$ (yr)\", \"Q (atoms/cm$^2$ yr/s)\"]\nmf.chain_summary(samples, walkers=8, labels=labels); # by default walker = dim(params) * 2\n</pre> labels = [\"start date (yr)\", \"duration (yr)\", \"$\\phi$ (yr)\", \"Q (atoms/cm$^2$ yr/s)\"] mf.chain_summary(samples, walkers=8, labels=labels); # by default walker = dim(params) * 2 <pre>Parameter $\\phi$ (yr) in chain Chain 1 is not constrained\n</pre> <p>This is a rough estimate of the posterior of these parameters. We can get a much better corner plot if the burn-in steps and the production steps are higher (say 1000).</p> <p>We can also define a custom parametric production model for fitting a MultiFitter. Here we will use a simple flat production function with a super gaussian spike. The only parameters for this model are: start date of the event, duration of the event, spike production</p> In\u00a0[5]: Copied! <pre>@jit\ndef super_gaussian(t, start_time, duration, area):\n    middle = start_time + duration / 2.\n    height = area / duration\n    return height * jnp.exp(- ((t - middle) / (1. / 1.93516 * duration)) ** 16.)\n\n@jit\ndef super_gaussian_pulse(t, *args):\n    start_time, duration, area = jnp.array(list(args)).reshape(-1)\n    height = super_gaussian(t, start_time, duration, area)\n    production = 1.76 + height # 1.76 is the default steady state production rate\n    return production\n</pre> @jit def super_gaussian(t, start_time, duration, area):     middle = start_time + duration / 2.     height = area / duration     return height * jnp.exp(- ((t - middle) / (1. / 1.93516 * duration)) ** 16.)  @jit def super_gaussian_pulse(t, *args):     start_time, duration, area = jnp.array(list(args)).reshape(-1)     height = super_gaussian(t, start_time, duration, area)     production = 1.76 + height # 1.76 is the default steady state production rate     return production In\u00a0[6]: Copied! <pre>mf, sampler = fitting.fit_event(year=775, \n                                path='../../notebooks/775CE/', \n                                production_model=super_gaussian_pulse, \n                                sampler=\"MCMC\", \n                                params=jnp.array([775.1, 0.3, 6.5]), \n                                low_bounds=jnp.array([770., 0., 0.]),\n                                up_bounds=jnp.array([780., 5., 15.]), \n                                burnin=500, production=500)\n\nsamples = sampler.copy()\nsamples[:,1] = 10**samples[:,1] # duration not log duration\nsamples[:,-1] = 10**samples[:,-1] # area not log area\n</pre> mf, sampler = fitting.fit_event(year=775,                                  path='../../notebooks/775CE/',                                  production_model=super_gaussian_pulse,                                  sampler=\"MCMC\",                                  params=jnp.array([775.1, 0.3, 6.5]),                                  low_bounds=jnp.array([770., 0., 0.]),                                 up_bounds=jnp.array([780., 5., 15.]),                                  burnin=500, production=500)  samples = sampler.copy() samples[:,1] = 10**samples[:,1] # duration not log duration samples[:,-1] = 10**samples[:,-1] # area not log area <pre>Retrieving data...\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 14/14 [00:00&lt;00:00, 188.56it/s]</pre> <pre>Running burn-in...\n</pre> <pre>\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [01:21&lt;00:00,  6.12it/s]\n</pre> <pre>Running production...\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [01:19&lt;00:00,  6.28it/s]\n</pre> In\u00a0[7]: Copied! <pre>labels = [\"start date (yr)\", \"duration (yr)\", \"Q (atoms/cm$^2$ yr/s)\"]\nmf.chain_summary(sampler, walkers=6, labels=labels);\n</pre> labels = [\"start date (yr)\", \"duration (yr)\", \"Q (atoms/cm$^2$ yr/s)\"] mf.chain_summary(sampler, walkers=6, labels=labels); <pre>Parameter Q (atoms/cm$^2$ yr/s) in chain Chain 1 is not constrained\n</pre>"},{"location":"notebooks/02_MultiFitter/#fitting-multiple-datasets-using-multifitter","title":"Fitting multiple datasets using MultiFitter\u00b6","text":"<p>Often we have multiple datasets for a Miyake event. Instead of fitting a model to each dataset indivudually, we can use a MultiFitter object to fit to all the datasets at once! Here's how we can do it,</p>"},{"location":"notebooks/02_MultiFitter/#example-1-fit-a-sinusoid-model-to-the-775ce-miyake-event-with-mcmc","title":"Example 1: Fit a sinusoid model to the <code>775CE</code> Miyake event with <code>MCMC</code>.\u00b6","text":""},{"location":"notebooks/02_MultiFitter/#example-2-fit-a-custom-model-to-the-775ce-miyake-event-with-mcmc","title":"Example 2: Fit a custom model to the <code>775CE</code> Miyake event with <code>MCMC</code>.\u00b6","text":""},{"location":"notebooks/03_InverseSolver/","title":"Fitting a single dataset using Inverse Solver","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport ticktack\nfrom ticktack import fitting\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nmpl.style.use('seaborn-colorblind')\n</pre> import numpy as np import ticktack from ticktack import fitting import matplotlib as mpl import matplotlib.pyplot as plt mpl.style.use('seaborn-colorblind') In\u00a0[2]: Copied! <pre>sf = fitting.SingleFitter('Guttler15', 'Guttler15')\nsf.load_data('miyake12.csv')\nsf.compile_production_model(\"inverse_solver\")\n</pre> sf = fitting.SingleFitter('Guttler15', 'Guttler15') sf.load_data('miyake12.csv') sf.compile_production_model(\"inverse_solver\") <p>Let's infer production rates from Monte Carlo samples of the d14c data in <code>miyake12.csv</code> using an inverse solver,</p> In\u00a0[3]: Copied! <pre>chain = sf.MC_reconstruct(iters=1000)\nprint(\"a sample from chain: \\n\", chain[0])\nprint(\"chain shape: \", chain.shape)\n</pre> chain = sf.MC_reconstruct(iters=1000) print(\"a sample from chain: \\n\", chain[0]) print(\"chain shape: \", chain.shape) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:11&lt;00:00, 86.18it/s]</pre> <pre>a sample from chain: \n [ 3.30259166 -0.58035717  3.66990759 -1.22151059  3.84375996  2.44877767\n  0.76190239  3.35334906  0.45990536 -1.69032714  5.3466338   1.61066658\n -0.98638563  4.77175444 -1.72507769 11.72212446 -0.24609793  1.83787816\n -1.52245896  4.8587668   0.79885272  3.56613786 -0.81719213  6.34347604\n -1.23213181  1.89105894  2.17688813  1.42199137]\nchain shape:  (1000, 28)\n</pre> <pre>\n</pre> <p>Visualise the mean and the standard deviation of the chain,</p> In\u00a0[4]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 4), dpi=100)\nmean = np.mean(chain, axis=0)\nstd = np.std(chain, axis=0)\nax.errorbar(sf.time_data, mean, color='k', drawstyle=\"steps\")\nax.fill_between(sf.time_data, mean - std, mean + std,\n                step='pre', alpha=0.6, facecolor=(0, 0, 0, .1),\n                edgecolor=(0, 0, 0, 0.8), lw=1.5)\nax.set_xlabel(\"Year (CE)\")\nax.set_ylabel(\"production rate (atoms/cm$^2$/s)\");\n</pre> fig, ax = plt.subplots(figsize=(6, 4), dpi=100) mean = np.mean(chain, axis=0) std = np.std(chain, axis=0) ax.errorbar(sf.time_data, mean, color='k', drawstyle=\"steps\") ax.fill_between(sf.time_data, mean - std, mean + std,                 step='pre', alpha=0.6, facecolor=(0, 0, 0, .1),                 edgecolor=(0, 0, 0, 0.8), lw=1.5) ax.set_xlabel(\"Year (CE)\") ax.set_ylabel(\"production rate (atoms/cm$^2$/s)\"); <p>Unlike our other approaches, we cannot directly call <code>sf.dc14</code> on the inverse solver since this production rate model does not require burn-in. The reconstruction function below addresses this issue, but it is only appropriate for inverse solver,</p> In\u00a0[5]: Copied! <pre>def d14c(params):\n    event = sf.run_event(y0=sf.steady_state_y0, params=(params,))\n    binned_d14c = sf.cbm.bin_data(event[:, sf.box_idx], sf.oversample, sf.annual, growth=sf.growth)\n    return (binned_d14c - \n            sf.steady_state_y0[sf.box_idx]) / sf.steady_state_y0[sf.box_idx] * 1000 + sf.d14c_data[0]\n</pre> def d14c(params):     event = sf.run_event(y0=sf.steady_state_y0, params=(params,))     binned_d14c = sf.cbm.bin_data(event[:, sf.box_idx], sf.oversample, sf.annual, growth=sf.growth)     return (binned_d14c -              sf.steady_state_y0[sf.box_idx]) / sf.steady_state_y0[sf.box_idx] * 1000 + sf.d14c_data[0] <p>Visualise the reconstruction,</p> In\u00a0[6]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 4), dpi=100)\ncolors = mpl.rcParams['axes.prop_cycle'].by_key()['color']\nax.errorbar(sf.time_data, sf.d14c_data, sf.d14c_data_error, fmt='o', \n            capsize=3, color=\"k\", alpha=0.7, label=\"data\")\nax.plot(sf.time_data, sf.d14c_data, color=\"k\", alpha=0.7)\nax.errorbar(sf.time_data, d14c(mean), fmt='o', color=colors[0], label=\"reconstruction\")\nax.legend(frameon=False)\nax.set_ylabel(\"$\\Delta^{14}$C (\u2030)\")\nax.set_xlabel(\"Year (CE)\");\n</pre> fig, ax = plt.subplots(figsize=(6, 4), dpi=100) colors = mpl.rcParams['axes.prop_cycle'].by_key()['color'] ax.errorbar(sf.time_data, sf.d14c_data, sf.d14c_data_error, fmt='o',              capsize=3, color=\"k\", alpha=0.7, label=\"data\") ax.plot(sf.time_data, sf.d14c_data, color=\"k\", alpha=0.7) ax.errorbar(sf.time_data, d14c(mean), fmt='o', color=colors[0], label=\"reconstruction\") ax.legend(frameon=False) ax.set_ylabel(\"$\\Delta^{14}$C (\u2030)\") ax.set_xlabel(\"Year (CE)\");"},{"location":"notebooks/03_InverseSolver/#fitting-a-single-dataset-using-inverse-solver","title":"Fitting a single dataset using Inverse Solver\u00b6","text":"<p>In addition to using a parametric model or a control-points approach, we can also infer the production rates and its uncertainties using an inverse solver.</p>"},{"location":"notebooks/04_Injection_Recovery_ControlPoints/","title":"Nonparametric Inference using Control Points","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport ticktack\nfrom ticktack import fitting\nimport jax.numpy as jnp\nfrom jax import jit\nfrom tqdm import tqdm\nplt.rcParams.update({\"text.usetex\": False})\n</pre> import numpy as np import matplotlib.pyplot as plt import ticktack from ticktack import fitting import jax.numpy as jnp from jax import jit from tqdm import tqdm plt.rcParams.update({\"text.usetex\": False}) In\u00a0[2]: Copied! <pre>@jit\ndef sine(t):\n    prod =  1.87 + 0.7 * 1.87 * jnp.sin(2 * jnp.pi / 11 * t + jnp.pi/2)\n    prod = prod * (t&gt;=sf.start) + (1.87 + 0.18 * 1.87 * jnp.sin(2 * jnp.pi / 11 * sf.start + jnp.pi/2)) * (1-(t&gt;=sf.start))\n    return prod\n</pre> @jit def sine(t):     prod =  1.87 + 0.7 * 1.87 * jnp.sin(2 * jnp.pi / 11 * t + jnp.pi/2)     prod = prod * (t&gt;=sf.start) + (1.87 + 0.18 * 1.87 * jnp.sin(2 * jnp.pi / 11 * sf.start + jnp.pi/2)) * (1-(t&gt;=sf.start))     return prod In\u00a0[3]: Copied! <pre>cbm = ticktack.load_presaved_model('Guttler15', production_rate_units = 'atoms/cm^2/s')\nsf = fitting.SingleFitter(cbm, cbm_model='Guttler15')\nsf.compile_production_model(model=sine)\nsf.time_data = jnp.arange(200, 230) \nsf.d14c_data_error = jnp.ones((sf.time_data.size,))\nsf.start = np.nanmin(sf.time_data)\nsf.end = np.nanmax(sf.time_data)\nsf.annual = jnp.arange(sf.start, sf.end + 1)\nsf.oversample = 1008\nsf.burn_in_time = jnp.arange(sf.start-2000, sf.start, 1.)\nsf.time_data_fine = jnp.linspace(sf.start, sf.end + 2, (sf.annual.size + 1) * sf.oversample)\nsf.offset = 0\nsf.mask = jnp.in1d(sf.annual, sf.time_data)\nsf.growth = sf.get_growth_vector(\"june-august\")\n</pre> cbm = ticktack.load_presaved_model('Guttler15', production_rate_units = 'atoms/cm^2/s') sf = fitting.SingleFitter(cbm, cbm_model='Guttler15') sf.compile_production_model(model=sine) sf.time_data = jnp.arange(200, 230)  sf.d14c_data_error = jnp.ones((sf.time_data.size,)) sf.start = np.nanmin(sf.time_data) sf.end = np.nanmax(sf.time_data) sf.annual = jnp.arange(sf.start, sf.end + 1) sf.oversample = 1008 sf.burn_in_time = jnp.arange(sf.start-2000, sf.start, 1.) sf.time_data_fine = jnp.linspace(sf.start, sf.end + 2, (sf.annual.size + 1) * sf.oversample) sf.offset = 0 sf.mask = jnp.in1d(sf.annual, sf.time_data) sf.growth = sf.get_growth_vector(\"june-august\") <p>Visualizing true d14c data and noisy d14c data. Adding unit gaussian noise on the d14c data gives SNR ~10.</p> In\u00a0[4]: Copied! <pre>np.random.seed(0)\nfig, ax = plt.subplots(figsize=(8, 4), dpi=80)\nd14c = sf.dc14()\nnoisy_d14c = np.array(d14c) + np.random.randn(d14c.size) # add unit gaussian noise\nax.plot(sf.time_data, d14c, \"-g\", label=\"true $\\Delta^{14}$C\", markersize=10)\nax.errorbar(sf.time_data, noisy_d14c, yerr=sf.d14c_data_error, \n             fmt=\"k\", linestyle='none', fillstyle=\"none\", capsize=2, label=\"noisy $\\Delta^{14}$C\")\nax.set_ylabel(\"$\\Delta^{14}$C (\u2030)\")\nax.set_xlabel(\"Calendar Year\");\nax.legend(frameon=False);\n</pre> np.random.seed(0) fig, ax = plt.subplots(figsize=(8, 4), dpi=80) d14c = sf.dc14() noisy_d14c = np.array(d14c) + np.random.randn(d14c.size) # add unit gaussian noise ax.plot(sf.time_data, d14c, \"-g\", label=\"true $\\Delta^{14}$C\", markersize=10) ax.errorbar(sf.time_data, noisy_d14c, yerr=sf.d14c_data_error,               fmt=\"k\", linestyle='none', fillstyle=\"none\", capsize=2, label=\"noisy $\\Delta^{14}$C\") ax.set_ylabel(\"$\\Delta^{14}$C (\u2030)\") ax.set_xlabel(\"Calendar Year\"); ax.legend(frameon=False); <p>Here we have the noisy d14c data stored in <code>sf.d14c_data</code>. Based on this noisy data, we want to recover the true production rate as best as we can. A non-parametric approach is using control points, which determine the shape of the production function. To avoid long runtime, we use only one control point per 2 years.</p> In\u00a0[5]: Copied! <pre>sf.d14c_data = jnp.array(noisy_d14c)\nsf.compile_production_model(model=\"control_points\")\nsf.control_points_time = jnp.arange(sf.start, sf.end, 2)\nprint(\"%d years in the period, %d control-points used\" % (sf.annual.size, sf.control_points_time.size))\n</pre> sf.d14c_data = jnp.array(noisy_d14c) sf.compile_production_model(model=\"control_points\") sf.control_points_time = jnp.arange(sf.start, sf.end, 2) print(\"%d years in the period, %d control-points used\" % (sf.annual.size, sf.control_points_time.size)) <pre>30 years in the period, 15 control-points used\n</pre> <p>Fitting the control points using the L-BFGS-B method from <code>scipy.minimize.optimize</code>,</p> In\u00a0[6]: Copied! <pre>%%time\nsoln = sf.fit_ControlPoints()\n</pre> %%time soln = sf.fit_ControlPoints() <pre>CPU times: user 1min 57s, sys: 334 ms, total: 1min 57s\nWall time: 1min 57s\n</pre> In\u00a0[7]: Copied! <pre>fig, ax = plt.subplots(figsize=(8, 4), dpi=80)\nax.plot(sf.control_points_time, soln.x, \".b\", markersize=7, label=\"recovered production rate\")\nax.plot(sf.time_data_fine, sine(sf.time_data_fine), 'k', label='true production rate')\nax.set_ylabel(\"Production rate (atoms cm$^2$s$^{-1}$)\");\nax.set_xlabel(\"Calendar Year\");\nax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.13), frameon=False);\n</pre> fig, ax = plt.subplots(figsize=(8, 4), dpi=80) ax.plot(sf.control_points_time, soln.x, \".b\", markersize=7, label=\"recovered production rate\") ax.plot(sf.time_data_fine, sine(sf.time_data_fine), 'k', label='true production rate') ax.set_ylabel(\"Production rate (atoms cm$^2$s$^{-1}$)\"); ax.set_xlabel(\"Calendar Year\"); ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.13), frameon=False); In\u00a0[8]: Copied! <pre>fig, ax = plt.subplots(figsize=(10, 5), dpi=80)\nax.plot(sf.time_data, d14c, \"-r\", label=\"true $\\Delta^{14}$C\", markersize=10)\nax.errorbar(sf.time_data, noisy_d14c, yerr=sf.d14c_data_error,  \n            fmt=\"k\", linestyle='none', fillstyle=\"none\", capsize=2, label=\"noisy $\\Delta^{14}$C\")\nax.plot(sf.time_data, sf.dc14(soln.x), \".b\", label=\"recovered $\\Delta^{14}$C\", markersize=10)\nax.set_ylabel(\"$\\Delta^{14}$C (\u2030)\");\nax.set_xlabel(\"Calendar Year\");\nax.legend(frameon=False);\n</pre> fig, ax = plt.subplots(figsize=(10, 5), dpi=80) ax.plot(sf.time_data, d14c, \"-r\", label=\"true $\\Delta^{14}$C\", markersize=10) ax.errorbar(sf.time_data, noisy_d14c, yerr=sf.d14c_data_error,               fmt=\"k\", linestyle='none', fillstyle=\"none\", capsize=2, label=\"noisy $\\Delta^{14}$C\") ax.plot(sf.time_data, sf.dc14(soln.x), \".b\", label=\"recovered $\\Delta^{14}$C\", markersize=10) ax.set_ylabel(\"$\\Delta^{14}$C (\u2030)\"); ax.set_xlabel(\"Calendar Year\"); ax.legend(frameon=False); <p>We now use MCMC to sample the posterior distribution for the control points using the affine-invariant sampler <code>emcee</code>:</p> In\u00a0[9]: Copied! <pre>sampler = sf.MarkovChainSampler(soln.x, sf.log_joint_likelihood_gp, burnin=500, \n                                production=500, \n                                args=(np.zeros(soln.x.shape), \n                                     np.ones(soln.x.shape) * 100)\n                               )\n</pre> sampler = sf.MarkovChainSampler(soln.x, sf.log_joint_likelihood_gp, burnin=500,                                  production=500,                                  args=(np.zeros(soln.x.shape),                                       np.ones(soln.x.shape) * 100)                                ) <pre>Running burn-in...\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [10:21&lt;00:00,  1.24s/it]\n</pre> <pre>Running production...\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [10:15&lt;00:00,  1.23s/it]\n</pre> <p>Let's visualize the diversity of samples and quantify the uncertainty on our fitted production rate. We do pretty well!</p> In\u00a0[10]: Copied! <pre>fig, (ax1, ax2) = plt.subplots(2, figsize=(8, 8), sharex=True, gridspec_kw={'height_ratios': [2, 1]}, dpi=80)\nfig.subplots_adjust(hspace=0.05)\nplt.rcParams.update({\"text.usetex\": False})\nidx = np.random.randint(len(sampler), size=100)\nfor param in tqdm(sampler[idx]):\n    ax1.plot(sf.time_data_fine, sf.dc14_fine(params=param), alpha=0.05, color=\"g\")\n\nfor param in tqdm(sampler[idx][:30]):\n    ax2.plot(sf.time_data_fine, sf.production(sf.time_data_fine, *param), alpha=0.2, color=\"g\")\n\nax1.errorbar(sf.time_data + sf.time_offset, sf.d14c_data, yerr=sf.d14c_data_error, \n             fmt=\"ok\", capsize=3, markersize=6, elinewidth=3, label=\"noisy $\\Delta^{14}$C\")\nax1.legend(frameon=False);\nax1.set_ylabel(\"$\\Delta^{14}$C (\u2030)\")\nax2.set_xlabel(\"Calendar Year\");\nax2.set_ylabel(\"Production rate (atoms cm$^2$s$^{-1}$)\");\n</pre> fig, (ax1, ax2) = plt.subplots(2, figsize=(8, 8), sharex=True, gridspec_kw={'height_ratios': [2, 1]}, dpi=80) fig.subplots_adjust(hspace=0.05) plt.rcParams.update({\"text.usetex\": False}) idx = np.random.randint(len(sampler), size=100) for param in tqdm(sampler[idx]):     ax1.plot(sf.time_data_fine, sf.dc14_fine(params=param), alpha=0.05, color=\"g\")  for param in tqdm(sampler[idx][:30]):     ax2.plot(sf.time_data_fine, sf.production(sf.time_data_fine, *param), alpha=0.2, color=\"g\")  ax1.errorbar(sf.time_data + sf.time_offset, sf.d14c_data, yerr=sf.d14c_data_error,               fmt=\"ok\", capsize=3, markersize=6, elinewidth=3, label=\"noisy $\\Delta^{14}$C\") ax1.legend(frameon=False); ax1.set_ylabel(\"$\\Delta^{14}$C (\u2030)\") ax2.set_xlabel(\"Calendar Year\"); ax2.set_ylabel(\"Production rate (atoms cm$^2$s$^{-1}$)\"); <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:08&lt;00:00, 11.30it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [00:00&lt;00:00, 89.03it/s]\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/04_Injection_Recovery_ControlPoints/#nonparametric-inference-using-control-points","title":"Nonparametric Inference using Control Points\u00b6","text":"<p>In this notebook we simulate noisy \u039414C data, from a sinusoidal production rate function, and try to recover the production rates using control points interpolated by a Gaussian Process.</p> <p>The control points are first fitted by local optimization, with objective function being the negative chi2 likelihood of the model with a GP regularization term. We then use this to initialize an MCMC sampler to quantify the uncertainties.</p>"},{"location":"notebooks/04_Injection_Recovery_ControlPoints/#simulating-noisy-d14c-data","title":"Simulating Noisy d14c data\u00b6","text":"<p>We start by defining a parametric production rate function to simulate data for injection and recovery. For this example, we use a sinusoid with a 11-year period. In the next cell, the attributes for a <code>SingleFitter</code> have been defined explicitly. In practice, one can just call <code>sf.load_data(filename.csv)</code>, provided the csv file is in the required structure (see <code>example.csv</code>).</p>"},{"location":"notebooks/05_Fitting_Flat/","title":"Fitting with flat production and constant sampling","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nimport ticktack\nfrom ticktack import fitting\n\nfrom tqdm import tqdm\nfrom matplotlib.lines import Line2D\n</pre> import numpy as np import matplotlib.pyplot as plt  import ticktack from ticktack import fitting  from tqdm import tqdm from matplotlib.lines import Line2D <p>Now, we load a presaved model; <code>ticktack</code> currently has pre-saved reimplementations of the carbon box models from 'Guttler15', 'Brehm21', 'Miyake17', or 'Buntgen18'.</p> In\u00a0[2]: Copied! <pre>cbm = ticktack.load_presaved_model(\"Guttler15\", production_rate_units = \"atoms/cm^2/s\")\n</pre> cbm = ticktack.load_presaved_model(\"Guttler15\", production_rate_units = \"atoms/cm^2/s\") <p>Now we initialize a <code>SingleFitter</code> object using this carbon box model, together with the data from Miyake et al, 2012. This will handle Bayesian inference of production rates conditioned on these data.</p> In\u00a0[3]: Copied! <pre>sf = fitting.SingleFitter(cbm, cbm_model=\"Guttler15\",adaptive=False)\nsf.load_data(\"miyake12.csv\")\nsf.compile_production_model(model=\"spike_only\")\n</pre> sf = fitting.SingleFitter(cbm, cbm_model=\"Guttler15\",adaptive=False) sf.load_data(\"miyake12.csv\") sf.compile_production_model(model=\"spike_only\") <p>The default engine for sampling from this posterior is emcee. We are working on implementing nested sampling and variational inference. We call <code>emcee</code> from a method of the <code>SingleFitter</code> object like this, where params are (arrival time in years, duration in years, solar cycle phase in years, and total radiocarbon delivered in production rate times years).</p> In\u00a0[4]: Copied! <pre>%%time\ndefault_params = np.array([775., np.log10(1./12),  np.log10(81./12)])\nsampler = sf.MarkovChainSampler(default_params, \n                                likelihood = sf.log_joint_likelihood, \n                                burnin = 1000, \n                                production = 2000, \n                                args = (np.array([770., np.log10(1/52.),  -2]), # lower bound\n                                np.array([780., np.log10(5.),  1.5]))         # upper bound \n                               )\nsamples = sampler.copy()\nsamples[:,1:] = 10**samples[:,1:]\n</pre> %%time default_params = np.array([775., np.log10(1./12),  np.log10(81./12)]) sampler = sf.MarkovChainSampler(default_params,                                  likelihood = sf.log_joint_likelihood,                                  burnin = 1000,                                  production = 2000,                                  args = (np.array([770., np.log10(1/52.),  -2]), # lower bound                                 np.array([780., np.log10(5.),  1.5]))         # upper bound                                 ) samples = sampler.copy() samples[:,1:] = 10**samples[:,1:]  <pre>Running burn-in...\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:08&lt;00:00, 111.82it/s]\n</pre> <pre>Running production...\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2000/2000 [00:17&lt;00:00, 116.55it/s]</pre> <pre>CPU times: user 25.7 s, sys: 4.98 s, total: 30.7 s\nWall time: 26.9 s\n</pre> <pre>\n</pre> <p>Plot of posterior surface using ChainConsumer:</p> In\u00a0[5]: Copied! <pre>labels = [\"Start Date (yr)\", \"Duration (yr)\", \"Q (atoms/cm$^2$ yr/s)\"]\nfig = sf.chain_summary(samples, 8, labels=labels, label_font_size=12, tick_font_size=12)\n</pre> labels = [\"Start Date (yr)\", \"Duration (yr)\", \"Q (atoms/cm$^2$ yr/s)\"] fig = sf.chain_summary(samples, 8, labels=labels, label_font_size=12, tick_font_size=12) <p>And a plot of models evaluated from samples of the posterior parameters shows a pretty good fit!</p> In\u00a0[6]: Copied! <pre>fig, (ax1, ax2) = plt.subplots(2, figsize=(8, 8), sharex=True, gridspec_kw={'height_ratios': [2, 1]}, dpi=80)\nfig.subplots_adjust(hspace=0.05)\nplt.rcParams.update({\"text.usetex\": False})\nidx = np.random.randint(len(sampler), size=100)\nfor param in tqdm(sampler[idx]):\n    ax1.plot(sf.time_data_fine, sf.dc14_fine(params=param), alpha=0.05, color=\"g\")\n\nfor param in tqdm(sampler[idx][:30]):\n    ax2.plot(sf.time_data_fine, sf.production(sf.time_data_fine, *param), alpha=0.2, color=\"g\")\n\nax1.errorbar(sf.time_data + sf.time_offset, sf.d14c_data, yerr=sf.d14c_data_error, \n             fmt=\"ok\", capsize=3, markersize=6, elinewidth=3, label=\"$\\Delta^{14}$C data\")\nax1.legend(frameon=False);\nax2.set_ylim(1, 10);\nax1.set_ylabel(\"$\\Delta^{14}$C (\u2030)\")\nax2.set_xlabel(\"Calendar Year\");\nax2.set_ylabel(\"Production rate (atoms cm$^2$s$^{-1}$)\");\n</pre> fig, (ax1, ax2) = plt.subplots(2, figsize=(8, 8), sharex=True, gridspec_kw={'height_ratios': [2, 1]}, dpi=80) fig.subplots_adjust(hspace=0.05) plt.rcParams.update({\"text.usetex\": False}) idx = np.random.randint(len(sampler), size=100) for param in tqdm(sampler[idx]):     ax1.plot(sf.time_data_fine, sf.dc14_fine(params=param), alpha=0.05, color=\"g\")  for param in tqdm(sampler[idx][:30]):     ax2.plot(sf.time_data_fine, sf.production(sf.time_data_fine, *param), alpha=0.2, color=\"g\")  ax1.errorbar(sf.time_data + sf.time_offset, sf.d14c_data, yerr=sf.d14c_data_error,               fmt=\"ok\", capsize=3, markersize=6, elinewidth=3, label=\"$\\Delta^{14}$C data\") ax1.legend(frameon=False); ax2.set_ylim(1, 10); ax1.set_ylabel(\"$\\Delta^{14}$C (\u2030)\") ax2.set_xlabel(\"Calendar Year\"); ax2.set_ylabel(\"Production rate (atoms cm$^2$s$^{-1}$)\"); <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 100.44it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [00:00&lt;00:00, 269.94it/s]\n</pre>"},{"location":"notebooks/05_Fitting_Flat/#fitting-with-flat-production-and-constant-sampling","title":"Fitting with flat production and constant sampling\u00b6","text":"<p>Sometimes you want to fit a simpler model, with a dead flat production for a long time. If you're using the default adaptive step size solver, this will break, sending the step size to some very large value and skipping most of the event! This tutorial shows how you can turn off the sinusoidal production and the adaptive step size solver.</p>"},{"location":"notebooks/Untitled/","title":"Untitled","text":"In\u00a0[2]: Copied! <pre>import numpy as np\nimport jax.numpy as jnp\nimport pytest\nimport ticktack\nfrom ticktack import fitting\n\nimport matplotlib.pyplot as plt\n\nfrom tqdm import tqdm\n</pre> import numpy as np import jax.numpy as jnp import pytest import ticktack from ticktack import fitting  import matplotlib.pyplot as plt  from tqdm import tqdm In\u00a0[3]: Copied! <pre>def SingleFitter_creation():\n    cbm = ticktack.load_presaved_model('Guttler15', production_rate_units='atoms/cm^2/s')\n    sf = fitting.SingleFitter(cbm, 'Guttler15', hemisphere=\"north\")\n    sf.time_data = jnp.arange(200, 210)\n    sf.d14c_data_error = jnp.ones((sf.time_data.size,))\n    sf.d14c_data = jnp.array([-169.81482498, -168.05109886, -163.81278239, -158.13313339,\n                              -153.23525037, -150.89762995, -151.11804461, -152.1036496 ,\n                              -151.60492619, -151.60492619])\n    sf.start = np.nanmin(sf.time_data)\n    sf.end = np.nanmax(sf.time_data)\n    sf.burn_in_time = jnp.arange(sf.start - 1000, sf.start, 1.)\n    sf.oversample = 1008\n    sf.annual = jnp.arange(sf.start, sf.end + 1)\n    sf.time_data_fine = jnp.linspace(jnp.min(sf.annual), jnp.max(sf.annual) + 2, (sf.annual.size + 1) * sf.oversample)\n    sf.offset = jnp.mean(sf.d14c_data[:4])\n    sf.mask = jnp.in1d(sf.annual, sf.time_data)\n    sf.growth = sf.get_growth_vector(\"april-september\")\n    return sf\n</pre> def SingleFitter_creation():     cbm = ticktack.load_presaved_model('Guttler15', production_rate_units='atoms/cm^2/s')     sf = fitting.SingleFitter(cbm, 'Guttler15', hemisphere=\"north\")     sf.time_data = jnp.arange(200, 210)     sf.d14c_data_error = jnp.ones((sf.time_data.size,))     sf.d14c_data = jnp.array([-169.81482498, -168.05109886, -163.81278239, -158.13313339,                               -153.23525037, -150.89762995, -151.11804461, -152.1036496 ,                               -151.60492619, -151.60492619])     sf.start = np.nanmin(sf.time_data)     sf.end = np.nanmax(sf.time_data)     sf.burn_in_time = jnp.arange(sf.start - 1000, sf.start, 1.)     sf.oversample = 1008     sf.annual = jnp.arange(sf.start, sf.end + 1)     sf.time_data_fine = jnp.linspace(jnp.min(sf.annual), jnp.max(sf.annual) + 2, (sf.annual.size + 1) * sf.oversample)     sf.offset = jnp.mean(sf.d14c_data[:4])     sf.mask = jnp.in1d(sf.annual, sf.time_data)     sf.growth = sf.get_growth_vector(\"april-september\")     return sf  In\u00a0[24]: Copied! <pre>sf = SingleFitter_creation()\nsf.compile_production_model(model=\"simple_sinusoid\")\n</pre> sf = SingleFitter_creation() sf.compile_production_model(model=\"simple_sinusoid\") In\u00a0[14]: Copied! <pre>cbm = sf.cbm\n</pre> cbm = sf.cbm In\u00a0[15]: Copied! <pre>true_params = jnp.array([205., np.log10(1. / 12), jnp.pi / 2., np.log10(81. / 12)])\n</pre> true_params = jnp.array([205., np.log10(1. / 12), jnp.pi / 2., np.log10(81. / 12)]) In\u00a0[26]: Copied! <pre>data = sf.dc14(true_params)\n</pre> data = sf.dc14(true_params) In\u00a0[29]: Copied! <pre>plt.plot(sf.time_data,data,'.')\n</pre> plt.plot(sf.time_data,data,'.') Out[29]: <pre>[&lt;matplotlib.lines.Line2D at 0x7fa7f8333c40&gt;]</pre> In\u00a0[30]: Copied! <pre>data\n</pre> data Out[30]: <pre>DeviceArray([-164.90491016, -164.31385509, -164.19279432, -164.57768418,\n             -165.33252032, -152.60046413, -150.44363798, -150.40669362,\n             -150.88854914, -151.27141576], dtype=float64)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/unit_tests/","title":"Unit tests","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport jax.numpy as jnp\nimport pytest\nimport ticktack\nfrom ticktack import fitting\n\nimport matplotlib.pyplot as plt\n\nfrom tqdm import tqdm\n</pre> import numpy as np import jax.numpy as jnp import pytest import ticktack from ticktack import fitting  import matplotlib.pyplot as plt  from tqdm import tqdm In\u00a0[2]: Copied! <pre>def SingleFitter_creation():\n    cbm = ticktack.load_presaved_model('Guttler15', production_rate_units='atoms/cm^2/s')\n    sf = fitting.SingleFitter(cbm, 'Guttler15', hemisphere=\"north\")\n    sf.time_data = jnp.arange(200, 210)\n    sf.d14c_data_error = jnp.ones((sf.time_data.size,))\n    sf.d14c_data = jnp.array([-164.90491016, -164.31385509, -164.19279432, -164.57768418,\n             -165.33252032, -152.60046413, -150.44363798, -150.40669362,\n             -150.88854914, -151.27141576]) # output of simple_sinusoid with data = sf.dc14(true_params)\n    # true params = jnp.array([205., np.log10(1. / 12), jnp.pi / 2., np.log10(81. / 12)])\n    sf.start = np.nanmin(sf.time_data)\n    sf.end = np.nanmax(sf.time_data)\n    sf.burn_in_time = jnp.arange(sf.start - 1000, sf.start, 1.)\n    sf.oversample = 1008\n    sf.annual = jnp.arange(sf.start, sf.end + 1)\n    sf.time_data_fine = jnp.linspace(jnp.min(sf.annual), jnp.max(sf.annual) + 2, (sf.annual.size + 1) * sf.oversample)\n    sf.offset = jnp.mean(sf.d14c_data[:4])\n    sf.mask = jnp.in1d(sf.annual, sf.time_data)\n    sf.growth = sf.get_growth_vector(\"april-september\")\n    return sf\n</pre> def SingleFitter_creation():     cbm = ticktack.load_presaved_model('Guttler15', production_rate_units='atoms/cm^2/s')     sf = fitting.SingleFitter(cbm, 'Guttler15', hemisphere=\"north\")     sf.time_data = jnp.arange(200, 210)     sf.d14c_data_error = jnp.ones((sf.time_data.size,))     sf.d14c_data = jnp.array([-164.90491016, -164.31385509, -164.19279432, -164.57768418,              -165.33252032, -152.60046413, -150.44363798, -150.40669362,              -150.88854914, -151.27141576]) # output of simple_sinusoid with data = sf.dc14(true_params)     # true params = jnp.array([205., np.log10(1. / 12), jnp.pi / 2., np.log10(81. / 12)])     sf.start = np.nanmin(sf.time_data)     sf.end = np.nanmax(sf.time_data)     sf.burn_in_time = jnp.arange(sf.start - 1000, sf.start, 1.)     sf.oversample = 1008     sf.annual = jnp.arange(sf.start, sf.end + 1)     sf.time_data_fine = jnp.linspace(jnp.min(sf.annual), jnp.max(sf.annual) + 2, (sf.annual.size + 1) * sf.oversample)     sf.offset = jnp.mean(sf.d14c_data[:4])     sf.mask = jnp.in1d(sf.annual, sf.time_data)     sf.growth = sf.get_growth_vector(\"april-september\")     return sf In\u00a0[3]: Copied! <pre>def MultiFitter_creation(SingleFitter_creation):\n    mf = fitting.MultiFitter()\n    SingleFitter_creation.compile_production_model(model=\"simple_sinusoid\")\n    mf.add_SingleFitter(SingleFitter_creation)\n    mf.add_SingleFitter(SingleFitter_creation)\n    mf.compile()\n    return mf\n</pre> def MultiFitter_creation(SingleFitter_creation):     mf = fitting.MultiFitter()     SingleFitter_creation.compile_production_model(model=\"simple_sinusoid\")     mf.add_SingleFitter(SingleFitter_creation)     mf.add_SingleFitter(SingleFitter_creation)     mf.compile()     return mf  In\u00a0[4]: Copied! <pre>sf = SingleFitter_creation()\nmf = MultiFitter_creation(sf)\n# out = .multi_likelihood(params=jnp.array([205., np.log10(1. / 12), \n#                                                               jnp.pi / 2., np.log10(81. / 12)]))\n</pre> sf = SingleFitter_creation() mf = MultiFitter_creation(sf) # out = .multi_likelihood(params=jnp.array([205., np.log10(1. / 12),  #                                                               jnp.pi / 2., np.log10(81. / 12)])) In\u00a0[5]: Copied! <pre>plt.errorbar(sf.time_data,sf.d14c_data,yerr=sf.d14c_data_error,linestyle='--')\n</pre> plt.errorbar(sf.time_data,sf.d14c_data,yerr=sf.d14c_data_error,linestyle='--') Out[5]: <pre>&lt;ErrorbarContainer object of 3 artists&gt;</pre> In\u00a0[6]: Copied! <pre>out = mf.multi_likelihood(params=jnp.array([205., np.log10(1. / 12), jnp.pi / 2., np.log10(81. / 12)]))\nprint(out)\n</pre> out = mf.multi_likelihood(params=jnp.array([205., np.log10(1. / 12), jnp.pi / 2., np.log10(81. / 12)])) print(out) <pre>-13.047058107518598\n</pre> In\u00a0[7]: Copied! <pre>out = mf.log_joint_likelihood(jnp.array([205.,np.log10(1. / 12), jnp.pi / 2., np.log10(81./12)]),\n                                                         jnp.array([200., -2, -jnp.pi, 0.]),\n                                                         jnp.array([210., 1, jnp.pi, 15.])\n                                                         )\nprint(out)\n</pre> out = mf.log_joint_likelihood(jnp.array([205.,np.log10(1. / 12), jnp.pi / 2., np.log10(81./12)]),                                                          jnp.array([200., -2, -jnp.pi, 0.]),                                                          jnp.array([210., 1, jnp.pi, 15.])                                                          ) print(out) <pre>-13.047058107518598\n</pre> In\u00a0[8]: Copied! <pre>out = mf.log_joint_likelihood(jnp.array([211.,np.log10(1. / 12), jnp.pi / 2., np.log10(81./12)]),\n                                                         jnp.array([200., -2, -jnp.pi, 0.]),\n                                                         jnp.array([210., 1, jnp.pi, 15.])\n                                                         )\nprint(out)\n</pre> out = mf.log_joint_likelihood(jnp.array([211.,np.log10(1. / 12), jnp.pi / 2., np.log10(81./12)]),                                                          jnp.array([200., -2, -jnp.pi, 0.]),                                                          jnp.array([210., 1, jnp.pi, 15.])                                                          ) print(out) <pre>-inf\n</pre> In\u00a0[9]: Copied! <pre>sf.compile_production_model(model=\"simple_sinusoid\")\nsampler = sf.MarkovChainSampler(jnp.array([205.,np.log10(1. / 12), jnp.pi / 2., np.log10(81./12)]),\n                                         sf.log_joint_likelihood,\n                                         burnin=500,\n                                         production=500,\n                                         args=(jnp.array([200., -2, -jnp.pi, -2.0]),\n                                               jnp.array([209., 1, jnp.pi, 2.0]))\n                                         )\n# sampler[:,1] = 10**sampler[:,1] # duration not log duration\n# sampler[:,-1] = 10**sampler[:,-1] # area not log area\n</pre> sf.compile_production_model(model=\"simple_sinusoid\") sampler = sf.MarkovChainSampler(jnp.array([205.,np.log10(1. / 12), jnp.pi / 2., np.log10(81./12)]),                                          sf.log_joint_likelihood,                                          burnin=500,                                          production=500,                                          args=(jnp.array([200., -2, -jnp.pi, -2.0]),                                                jnp.array([209., 1, jnp.pi, 2.0]))                                          ) # sampler[:,1] = 10**sampler[:,1] # duration not log duration # sampler[:,-1] = 10**sampler[:,-1] # area not log area <pre>Running burn-in...\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:50&lt;00:00,  9.83it/s]\n</pre> <pre>Running production...\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:51&lt;00:00,  9.71it/s]\n</pre> In\u00a0[10]: Copied! <pre>labels = [\"Start Date (yr)\", \"Duration (yr)\", \"phi (yr)\", \"Area\"]\nfig = sf.chain_summary(sampler, 8, labels=labels, label_font_size=12, tick_font_size=12)\n</pre> labels = [\"Start Date (yr)\", \"Duration (yr)\", \"phi (yr)\", \"Area\"] fig = sf.chain_summary(sampler, 8, labels=labels, label_font_size=12, tick_font_size=12) <pre>WARNING:chainconsumer:Parameter Duration (yr) in chain Chain 0 is not constrained\n</pre> In\u00a0[11]: Copied! <pre>fig, (ax1, ax2) = plt.subplots(2, figsize=(8, 8), sharex=True, gridspec_kw={'height_ratios': [2, 1]}, dpi=80)\nfig.subplots_adjust(hspace=0.05)\nplt.rcParams.update({\"text.usetex\": False})\nidx = np.random.randint(len(sampler), size=100)\nfor param in tqdm(sampler[idx]):\n    ax1.plot(sf.time_data_fine, sf.dc14_fine(params=param), alpha=0.05, color=\"g\")\n\nfor param in tqdm(sampler[idx][:30]):\n    ax2.plot(sf.time_data_fine, sf.production(sf.time_data_fine, *param), alpha=0.2, color=\"g\")\n\nax1.errorbar(sf.time_data + sf.time_offset, sf.d14c_data, yerr=sf.d14c_data_error, \n             fmt=\"ok\", capsize=3, markersize=6, elinewidth=3, label=\"$\\Delta^{14}$C data\")\nax1.legend(frameon=False);\nax2.set_ylim(1, 10);\nax1.set_ylabel(\"$\\Delta^{14}$C (\u2030)\")\nax2.set_xlabel(\"Calendar Year\");\nax2.set_ylabel(\"Production rate (atoms cm$^2$s$^{-1}$)\");\n</pre> fig, (ax1, ax2) = plt.subplots(2, figsize=(8, 8), sharex=True, gridspec_kw={'height_ratios': [2, 1]}, dpi=80) fig.subplots_adjust(hspace=0.05) plt.rcParams.update({\"text.usetex\": False}) idx = np.random.randint(len(sampler), size=100) for param in tqdm(sampler[idx]):     ax1.plot(sf.time_data_fine, sf.dc14_fine(params=param), alpha=0.05, color=\"g\")  for param in tqdm(sampler[idx][:30]):     ax2.plot(sf.time_data_fine, sf.production(sf.time_data_fine, *param), alpha=0.2, color=\"g\")  ax1.errorbar(sf.time_data + sf.time_offset, sf.d14c_data, yerr=sf.d14c_data_error,               fmt=\"ok\", capsize=3, markersize=6, elinewidth=3, label=\"$\\Delta^{14}$C data\") ax1.legend(frameon=False); ax2.set_ylim(1, 10); ax1.set_ylabel(\"$\\Delta^{14}$C (\u2030)\") ax2.set_xlabel(\"Calendar Year\"); ax2.set_ylabel(\"Production rate (atoms cm$^2$s$^{-1}$)\"); <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:04&lt;00:00, 23.49it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [00:00&lt;00:00, 195.80it/s]\n</pre> <p>Testing the d14c function</p> In\u00a0[12]: Copied! <pre>sf.compile_production_model(model=\"simple_sinusoid\")\na = sf.dc14(params=jnp.array([205.,np.log10(1. / 12), jnp.pi / 2., np.log10(81./12)]))\n    \nsf.compile_production_model(model=\"flexible_sinusoid\")\nb = sf.dc14(params=(jnp.array([205., np.log10(1./12), jnp.pi/2., np.log10(81./12), np.log10(0.1)])))\n\nsf.compile_production_model(model=\"control_points\")\nc = sf.dc14(params=jnp.ones(sf.control_points_time.size))\n\n#     assert jnp.all(\n#         jnp.array([\n#             jnp.allclose(a, jnp.array([ 0.04804975,  0.63910482,  0.76016559,  0.37527574,\n#               -0.3795604 , 12.34915479, 14.50537971, 14.54228208,\n#               14.06061059, 13.67800247])),\n#             jnp.allclose(b, jnp.array([ 0.02669429,  0.35505823,  0.42231421,  0.20848652,\n#               -0.21086689, 12.90361593, 15.365865  , 15.52502989,\n#               14.93705643, 14.24820176])),\n#             jnp.allclose(c, jnp.array([-126.52752693, -126.57603706, -126.6245375 , -126.67302826,\n#               -126.72150935, -126.76998077, -126.81844254, -126.86689466,\n#               -126.91533713, -126.96376997]))\n#         ])\n</pre> sf.compile_production_model(model=\"simple_sinusoid\") a = sf.dc14(params=jnp.array([205.,np.log10(1. / 12), jnp.pi / 2., np.log10(81./12)]))      sf.compile_production_model(model=\"flexible_sinusoid\") b = sf.dc14(params=(jnp.array([205., np.log10(1./12), jnp.pi/2., np.log10(81./12), np.log10(0.1)])))  sf.compile_production_model(model=\"control_points\") c = sf.dc14(params=jnp.ones(sf.control_points_time.size))  #     assert jnp.all( #         jnp.array([ #             jnp.allclose(a, jnp.array([ 0.04804975,  0.63910482,  0.76016559,  0.37527574, #               -0.3795604 , 12.34915479, 14.50537971, 14.54228208, #               14.06061059, 13.67800247])), #             jnp.allclose(b, jnp.array([ 0.02669429,  0.35505823,  0.42231421,  0.20848652, #               -0.21086689, 12.90361593, 15.365865  , 15.52502989, #               14.93705643, 14.24820176])), #             jnp.allclose(c, jnp.array([-126.52752693, -126.57603706, -126.6245375 , -126.67302826, #               -126.72150935, -126.76998077, -126.81844254, -126.86689466, #               -126.91533713, -126.96376997])) #         ])  In\u00a0[13]: Copied! <pre>aa = jnp.array([ 0.04804975,  0.63910482,  0.76016559,  0.37527574,\n              -0.3795604 , 12.34915479, 14.50537971, 14.54228208,\n              14.06061059, 13.67800247])\n\nbb = jnp.array([ 0.02669429,  0.35505823,  0.42231421,  0.20848652,\n              -0.21086689, 12.90361593, 15.365865  , 15.52502989,\n              14.93705643, 14.24820176])\n\ncc = jnp.array([-126.52752693, -126.57603706, -126.6245375 , -126.67302826,\n              -126.72150935, -126.76998077, -126.81844254, -126.86689466,\n              -126.91533713, -126.96376997])\n</pre> aa = jnp.array([ 0.04804975,  0.63910482,  0.76016559,  0.37527574,               -0.3795604 , 12.34915479, 14.50537971, 14.54228208,               14.06061059, 13.67800247])  bb = jnp.array([ 0.02669429,  0.35505823,  0.42231421,  0.20848652,               -0.21086689, 12.90361593, 15.365865  , 15.52502989,               14.93705643, 14.24820176])  cc = jnp.array([-126.52752693, -126.57603706, -126.6245375 , -126.67302826,               -126.72150935, -126.76998077, -126.81844254, -126.86689466,               -126.91533713, -126.96376997]) In\u00a0[14]: Copied! <pre>fig, (ax1, ax2, ax3) = plt.subplots(1,3,figsize=(12.0,4.0))\nax1.plot(sf.time_data,a,'.--',c='C0')\nax1.plot(sf.time_data,aa+sf.offset,'*',c='C0')\n\nax2.plot(sf.time_data,b,'.--',c='C1')\nax2.plot(sf.time_data,bb+sf.offset,'*',c='C1')\n\nax3.plot(sf.time_data,c,'.--',c='C2')\nax3.plot(sf.time_data,cc+sf.offset,'*',c='C2')\n</pre> fig, (ax1, ax2, ax3) = plt.subplots(1,3,figsize=(12.0,4.0)) ax1.plot(sf.time_data,a,'.--',c='C0') ax1.plot(sf.time_data,aa+sf.offset,'*',c='C0')  ax2.plot(sf.time_data,b,'.--',c='C1') ax2.plot(sf.time_data,bb+sf.offset,'*',c='C1')  ax3.plot(sf.time_data,c,'.--',c='C2') ax3.plot(sf.time_data,cc+sf.offset,'*',c='C2') Out[14]: <pre>[&lt;matplotlib.lines.Line2D at 0x7faa88686d30&gt;]</pre> In\u00a0[15]: Copied! <pre>np.allclose(b,bb-sf.offset)\n</pre> np.allclose(b,bb-sf.offset) Out[15]: <pre>False</pre> In\u00a0[16]: Copied! <pre>np.allclose(a-sf.offset,aa,rtol=1e-3)\n</pre> np.allclose(a-sf.offset,aa,rtol=1e-3) Out[16]: <pre>True</pre> In\u00a0[17]: Copied! <pre>sf.compile_production_model(model=\"simple_sinusoid\")\na = sf.dc14_fine(params=jnp.array([205.,np.log10(1. / 12), jnp.pi / 2., np.log10(81./12)]))[-9:]\n\nsf.compile_production_model(model=\"flexible_sinusoid\")\nb = sf.dc14_fine(params=jnp.array([205., np.log10(1./12), jnp.pi/2., np.log10(81./12), np.log10(0.1)]))[-9:]\n\nsf.compile_production_model(model=\"control_points\")\nc = sf.dc14_fine(params=jnp.ones(sf.control_points_time.size))[-9:]\n\naa = jnp.array([13.42488917, 13.42474906, 13.42460886, 13.42446859,\n          13.42432823, 13.42418779, 13.42404727, 13.42390667,\n          13.42376598])\n\nbb = jnp.array([13.37697866, 13.37644154, 13.37590442, 13.37536731,\n          13.37483019, 13.37429309, 13.37375598, 13.37321888,\n          13.37268179])\n\ncc = jnp.array([-127.03599304, -127.03604107, -127.0360891 , -127.03613713,\n          -127.03618515, -127.03623318, -127.03628121, -127.03632924,\n          -127.03637727])\n</pre> sf.compile_production_model(model=\"simple_sinusoid\") a = sf.dc14_fine(params=jnp.array([205.,np.log10(1. / 12), jnp.pi / 2., np.log10(81./12)]))[-9:]  sf.compile_production_model(model=\"flexible_sinusoid\") b = sf.dc14_fine(params=jnp.array([205., np.log10(1./12), jnp.pi/2., np.log10(81./12), np.log10(0.1)]))[-9:]  sf.compile_production_model(model=\"control_points\") c = sf.dc14_fine(params=jnp.ones(sf.control_points_time.size))[-9:]  aa = jnp.array([13.42488917, 13.42474906, 13.42460886, 13.42446859,           13.42432823, 13.42418779, 13.42404727, 13.42390667,           13.42376598])  bb = jnp.array([13.37697866, 13.37644154, 13.37590442, 13.37536731,           13.37483019, 13.37429309, 13.37375598, 13.37321888,           13.37268179])  cc = jnp.array([-127.03599304, -127.03604107, -127.0360891 , -127.03613713,           -127.03618515, -127.03623318, -127.03628121, -127.03632924,           -127.03637727]) In\u00a0[18]: Copied! <pre>fig, (ax1, ax2, ax3) = plt.subplots(1,3,figsize=(12.0,4.0))\nax1.plot(sf.time_data_fine[-9:],a/((aa+sf.offset)[-9]),'.--',c='C0')\nax1.plot(sf.time_data_fine[-9:],(aa+sf.offset)/(aa+sf.offset)[-9],'*',c='C0')\n\nax2.plot(sf.time_data_fine[-9:],b/(bb+sf.offset)[-9],'.--',c='C1')\nax2.plot(sf.time_data_fine[-9:],(bb+sf.offset)/(bb+sf.offset)[-9],'*',c='C1')\n\nax3.plot(sf.time_data_fine[-9:],c/(cc+sf.offset)[-9],'.--',c='C2')\nax3.plot(sf.time_data_fine[-9:],(cc+sf.offset)/(cc+sf.offset)[-9],'*',c='C2')\n</pre> fig, (ax1, ax2, ax3) = plt.subplots(1,3,figsize=(12.0,4.0)) ax1.plot(sf.time_data_fine[-9:],a/((aa+sf.offset)[-9]),'.--',c='C0') ax1.plot(sf.time_data_fine[-9:],(aa+sf.offset)/(aa+sf.offset)[-9],'*',c='C0')  ax2.plot(sf.time_data_fine[-9:],b/(bb+sf.offset)[-9],'.--',c='C1') ax2.plot(sf.time_data_fine[-9:],(bb+sf.offset)/(bb+sf.offset)[-9],'*',c='C1')  ax3.plot(sf.time_data_fine[-9:],c/(cc+sf.offset)[-9],'.--',c='C2') ax3.plot(sf.time_data_fine[-9:],(cc+sf.offset)/(cc+sf.offset)[-9],'*',c='C2') Out[18]: <pre>[&lt;matplotlib.lines.Line2D at 0x7faac9253b20&gt;]</pre> In\u00a0[19]: Copied! <pre>np.allclose(c-sf.offset,cc,rtol=1e-3)\n</pre> np.allclose(c-sf.offset,cc,rtol=1e-3) Out[19]: <pre>True</pre> In\u00a0[20]: Copied! <pre>cc/cc[-9]\n</pre> cc/cc[-9] Out[20]: <pre>DeviceArray([1.        , 1.00000038, 1.00000076, 1.00000113, 1.00000151,\n             1.00000189, 1.00000227, 1.00000265, 1.00000302],            dtype=float64)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"}]}